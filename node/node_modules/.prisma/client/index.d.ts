
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model deck
 * 
 */
export type deck = {
  id: number
  idUser: number
  vida: number
  maxVida: number
  nome: string
  foto: string
  idCard: number
  poder: number
}

/**
 * Model inimigo
 * 
 */
export type inimigo = {
  id: number
  nome: string
  foto: string
  fase: number
  idUsuario: number
  idInimigos: number
  poder: number
  vida: number
}

/**
 * Model card
 * 
 */
export type card = {
  id: number
  foto: string
  poder: number
  vida: number
  nome: string
}

/**
 * Model usuario
 * 
 */
export type usuario = {
  id: number
  token: string
  senha: string
  email: string
  foto: string
  nome: string
  fase: number
}

/**
 * Model inimigos
 * 
 */
export type inimigos = {
  id: number
  poder: number
  nome: string
  foto: string
  vida: number
  fase: number
}

/**
 * Model vitorias
 * 
 */
export type vitorias = {
  id: number
  vitorias: number
  usuarioId: number
}

/**
 * Model ranking
 * 
 */
export type ranking = {
  id: number
  ranking: number
  usuarioId: number
  nome: string
  foto: string
}

/**
 * Model ouro
 * 
 */
export type ouro = {
  id: number
  ouro: number
  usuarioId: number
}

/**
 * Model ouroCard
 * 
 */
export type ouroCard = {
  id: number
  ouro: number
  cardId: number
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Decks
 * const decks = await prisma.deck.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Decks
   * const decks = await prisma.deck.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>;

      /**
   * `prisma.deck`: Exposes CRUD operations for the **deck** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Decks
    * const decks = await prisma.deck.findMany()
    * ```
    */
  get deck(): Prisma.deckDelegate<GlobalReject>;

  /**
   * `prisma.inimigo`: Exposes CRUD operations for the **inimigo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inimigos
    * const inimigos = await prisma.inimigo.findMany()
    * ```
    */
  get inimigo(): Prisma.inimigoDelegate<GlobalReject>;

  /**
   * `prisma.card`: Exposes CRUD operations for the **card** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cards
    * const cards = await prisma.card.findMany()
    * ```
    */
  get card(): Prisma.cardDelegate<GlobalReject>;

  /**
   * `prisma.usuario`: Exposes CRUD operations for the **usuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuario.findMany()
    * ```
    */
  get usuario(): Prisma.usuarioDelegate<GlobalReject>;

  /**
   * `prisma.inimigos`: Exposes CRUD operations for the **inimigos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inimigos
    * const inimigos = await prisma.inimigos.findMany()
    * ```
    */
  get inimigos(): Prisma.inimigosDelegate<GlobalReject>;

  /**
   * `prisma.vitorias`: Exposes CRUD operations for the **vitorias** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vitorias
    * const vitorias = await prisma.vitorias.findMany()
    * ```
    */
  get vitorias(): Prisma.vitoriasDelegate<GlobalReject>;

  /**
   * `prisma.ranking`: Exposes CRUD operations for the **ranking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rankings
    * const rankings = await prisma.ranking.findMany()
    * ```
    */
  get ranking(): Prisma.rankingDelegate<GlobalReject>;

  /**
   * `prisma.ouro`: Exposes CRUD operations for the **ouro** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ouros
    * const ouros = await prisma.ouro.findMany()
    * ```
    */
  get ouro(): Prisma.ouroDelegate<GlobalReject>;

  /**
   * `prisma.ouroCard`: Exposes CRUD operations for the **ouroCard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OuroCards
    * const ouroCards = await prisma.ouroCard.findMany()
    * ```
    */
  get ouroCard(): Prisma.ouroCardDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export import Metrics = runtime.Metrics
  export import Metric = runtime.Metric
  export import MetricHistogram = runtime.MetricHistogram
  export import MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
   * Prisma Client JS version: 4.4.0
   * Query Engine version: f352a33b70356f46311da8b00d83386dd9f145d6
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export import FieldRef = runtime.FieldRef

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    deck: 'deck',
    inimigo: 'inimigo',
    card: 'card',
    usuario: 'usuario',
    inimigos: 'inimigos',
    vitorias: 'vitorias',
    ranking: 'ranking',
    ouro: 'ouro',
    ouroCard: 'ouroCard'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CardCountOutputType
   */


  export type CardCountOutputType = {
    deck: number
    ouroCard: number
  }

  export type CardCountOutputTypeSelect = {
    deck?: boolean
    ouroCard?: boolean
  }

  export type CardCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CardCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CardCountOutputType
    : S extends undefined
    ? never
    : S extends CardCountOutputTypeArgs
    ?'include' extends U
    ? CardCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof CardCountOutputType ? CardCountOutputType[P] : never
  } 
    : CardCountOutputType
  : CardCountOutputType




  // Custom InputTypes

  /**
   * CardCountOutputType without action
   */
  export type CardCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CardCountOutputType
     * 
    **/
    select?: CardCountOutputTypeSelect | null
  }



  /**
   * Count Type UsuarioCountOutputType
   */


  export type UsuarioCountOutputType = {
    deck: number
    inimigo: number
    ouro: number
    vitorias: number
  }

  export type UsuarioCountOutputTypeSelect = {
    deck?: boolean
    inimigo?: boolean
    ouro?: boolean
    vitorias?: boolean
  }

  export type UsuarioCountOutputTypeGetPayload<
    S extends boolean | null | undefined | UsuarioCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? UsuarioCountOutputType
    : S extends undefined
    ? never
    : S extends UsuarioCountOutputTypeArgs
    ?'include' extends U
    ? UsuarioCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof UsuarioCountOutputType ? UsuarioCountOutputType[P] : never
  } 
    : UsuarioCountOutputType
  : UsuarioCountOutputType




  // Custom InputTypes

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UsuarioCountOutputType
     * 
    **/
    select?: UsuarioCountOutputTypeSelect | null
  }



  /**
   * Count Type InimigosCountOutputType
   */


  export type InimigosCountOutputType = {
    inimigo: number
  }

  export type InimigosCountOutputTypeSelect = {
    inimigo?: boolean
  }

  export type InimigosCountOutputTypeGetPayload<
    S extends boolean | null | undefined | InimigosCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? InimigosCountOutputType
    : S extends undefined
    ? never
    : S extends InimigosCountOutputTypeArgs
    ?'include' extends U
    ? InimigosCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof InimigosCountOutputType ? InimigosCountOutputType[P] : never
  } 
    : InimigosCountOutputType
  : InimigosCountOutputType




  // Custom InputTypes

  /**
   * InimigosCountOutputType without action
   */
  export type InimigosCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the InimigosCountOutputType
     * 
    **/
    select?: InimigosCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model deck
   */


  export type AggregateDeck = {
    _count: DeckCountAggregateOutputType | null
    _avg: DeckAvgAggregateOutputType | null
    _sum: DeckSumAggregateOutputType | null
    _min: DeckMinAggregateOutputType | null
    _max: DeckMaxAggregateOutputType | null
  }

  export type DeckAvgAggregateOutputType = {
    id: number | null
    idUser: number | null
    vida: number | null
    maxVida: number | null
    idCard: number | null
    poder: number | null
  }

  export type DeckSumAggregateOutputType = {
    id: number | null
    idUser: number | null
    vida: number | null
    maxVida: number | null
    idCard: number | null
    poder: number | null
  }

  export type DeckMinAggregateOutputType = {
    id: number | null
    idUser: number | null
    vida: number | null
    maxVida: number | null
    nome: string | null
    foto: string | null
    idCard: number | null
    poder: number | null
  }

  export type DeckMaxAggregateOutputType = {
    id: number | null
    idUser: number | null
    vida: number | null
    maxVida: number | null
    nome: string | null
    foto: string | null
    idCard: number | null
    poder: number | null
  }

  export type DeckCountAggregateOutputType = {
    id: number
    idUser: number
    vida: number
    maxVida: number
    nome: number
    foto: number
    idCard: number
    poder: number
    _all: number
  }


  export type DeckAvgAggregateInputType = {
    id?: true
    idUser?: true
    vida?: true
    maxVida?: true
    idCard?: true
    poder?: true
  }

  export type DeckSumAggregateInputType = {
    id?: true
    idUser?: true
    vida?: true
    maxVida?: true
    idCard?: true
    poder?: true
  }

  export type DeckMinAggregateInputType = {
    id?: true
    idUser?: true
    vida?: true
    maxVida?: true
    nome?: true
    foto?: true
    idCard?: true
    poder?: true
  }

  export type DeckMaxAggregateInputType = {
    id?: true
    idUser?: true
    vida?: true
    maxVida?: true
    nome?: true
    foto?: true
    idCard?: true
    poder?: true
  }

  export type DeckCountAggregateInputType = {
    id?: true
    idUser?: true
    vida?: true
    maxVida?: true
    nome?: true
    foto?: true
    idCard?: true
    poder?: true
    _all?: true
  }

  export type DeckAggregateArgs = {
    /**
     * Filter which deck to aggregate.
     * 
    **/
    where?: deckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of decks to fetch.
     * 
    **/
    orderBy?: Enumerable<deckOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: deckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` decks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` decks.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned decks
    **/
    _count?: true | DeckCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeckAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeckSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeckMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeckMaxAggregateInputType
  }

  export type GetDeckAggregateType<T extends DeckAggregateArgs> = {
        [P in keyof T & keyof AggregateDeck]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeck[P]>
      : GetScalarType<T[P], AggregateDeck[P]>
  }




  export type DeckGroupByArgs = {
    where?: deckWhereInput
    orderBy?: Enumerable<deckOrderByWithAggregationInput>
    by: Array<DeckScalarFieldEnum>
    having?: deckScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeckCountAggregateInputType | true
    _avg?: DeckAvgAggregateInputType
    _sum?: DeckSumAggregateInputType
    _min?: DeckMinAggregateInputType
    _max?: DeckMaxAggregateInputType
  }


  export type DeckGroupByOutputType = {
    id: number
    idUser: number
    vida: number
    maxVida: number
    nome: string
    foto: string
    idCard: number
    poder: number
    _count: DeckCountAggregateOutputType | null
    _avg: DeckAvgAggregateOutputType | null
    _sum: DeckSumAggregateOutputType | null
    _min: DeckMinAggregateOutputType | null
    _max: DeckMaxAggregateOutputType | null
  }

  type GetDeckGroupByPayload<T extends DeckGroupByArgs> = PrismaPromise<
    Array<
      PickArray<DeckGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeckGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeckGroupByOutputType[P]>
            : GetScalarType<T[P], DeckGroupByOutputType[P]>
        }
      >
    >


  export type deckSelect = {
    id?: boolean
    idUser?: boolean
    vida?: boolean
    maxVida?: boolean
    nome?: boolean
    foto?: boolean
    idCard?: boolean
    poder?: boolean
    card?: boolean | cardArgs
    usuario?: boolean | usuarioArgs
  }

  export type deckInclude = {
    card?: boolean | cardArgs
    usuario?: boolean | usuarioArgs
  }

  export type deckGetPayload<
    S extends boolean | null | undefined | deckArgs,
    U = keyof S
      > = S extends true
        ? deck
    : S extends undefined
    ? never
    : S extends deckArgs | deckFindManyArgs
    ?'include' extends U
    ? deck  & {
    [P in TrueKeys<S['include']>]:
        P extends 'card' ? cardGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'usuario' ? usuarioGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'card' ? cardGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'usuario' ? usuarioGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof deck ? deck[P] : never
  } 
    : deck
  : deck


  type deckCountArgs = Merge<
    Omit<deckFindManyArgs, 'select' | 'include'> & {
      select?: DeckCountAggregateInputType | true
    }
  >

  export interface deckDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Deck that matches the filter.
     * @param {deckFindUniqueArgs} args - Arguments to find a Deck
     * @example
     * // Get one Deck
     * const deck = await prisma.deck.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends deckFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, deckFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'deck'> extends True ? CheckSelect<T, Prisma__deckClient<deck>, Prisma__deckClient<deckGetPayload<T>>> : CheckSelect<T, Prisma__deckClient<deck | null, null>, Prisma__deckClient<deckGetPayload<T> | null, null>>

    /**
     * Find the first Deck that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deckFindFirstArgs} args - Arguments to find a Deck
     * @example
     * // Get one Deck
     * const deck = await prisma.deck.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends deckFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, deckFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'deck'> extends True ? CheckSelect<T, Prisma__deckClient<deck>, Prisma__deckClient<deckGetPayload<T>>> : CheckSelect<T, Prisma__deckClient<deck | null, null>, Prisma__deckClient<deckGetPayload<T> | null, null>>

    /**
     * Find zero or more Decks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deckFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Decks
     * const decks = await prisma.deck.findMany()
     * 
     * // Get first 10 Decks
     * const decks = await prisma.deck.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deckWithIdOnly = await prisma.deck.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends deckFindManyArgs>(
      args?: SelectSubset<T, deckFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<deck>>, PrismaPromise<Array<deckGetPayload<T>>>>

    /**
     * Create a Deck.
     * @param {deckCreateArgs} args - Arguments to create a Deck.
     * @example
     * // Create one Deck
     * const Deck = await prisma.deck.create({
     *   data: {
     *     // ... data to create a Deck
     *   }
     * })
     * 
    **/
    create<T extends deckCreateArgs>(
      args: SelectSubset<T, deckCreateArgs>
    ): CheckSelect<T, Prisma__deckClient<deck>, Prisma__deckClient<deckGetPayload<T>>>

    /**
     * Create many Decks.
     *     @param {deckCreateManyArgs} args - Arguments to create many Decks.
     *     @example
     *     // Create many Decks
     *     const deck = await prisma.deck.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends deckCreateManyArgs>(
      args?: SelectSubset<T, deckCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Deck.
     * @param {deckDeleteArgs} args - Arguments to delete one Deck.
     * @example
     * // Delete one Deck
     * const Deck = await prisma.deck.delete({
     *   where: {
     *     // ... filter to delete one Deck
     *   }
     * })
     * 
    **/
    delete<T extends deckDeleteArgs>(
      args: SelectSubset<T, deckDeleteArgs>
    ): CheckSelect<T, Prisma__deckClient<deck>, Prisma__deckClient<deckGetPayload<T>>>

    /**
     * Update one Deck.
     * @param {deckUpdateArgs} args - Arguments to update one Deck.
     * @example
     * // Update one Deck
     * const deck = await prisma.deck.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends deckUpdateArgs>(
      args: SelectSubset<T, deckUpdateArgs>
    ): CheckSelect<T, Prisma__deckClient<deck>, Prisma__deckClient<deckGetPayload<T>>>

    /**
     * Delete zero or more Decks.
     * @param {deckDeleteManyArgs} args - Arguments to filter Decks to delete.
     * @example
     * // Delete a few Decks
     * const { count } = await prisma.deck.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends deckDeleteManyArgs>(
      args?: SelectSubset<T, deckDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Decks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deckUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Decks
     * const deck = await prisma.deck.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends deckUpdateManyArgs>(
      args: SelectSubset<T, deckUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Deck.
     * @param {deckUpsertArgs} args - Arguments to update or create a Deck.
     * @example
     * // Update or create a Deck
     * const deck = await prisma.deck.upsert({
     *   create: {
     *     // ... data to create a Deck
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Deck we want to update
     *   }
     * })
    **/
    upsert<T extends deckUpsertArgs>(
      args: SelectSubset<T, deckUpsertArgs>
    ): CheckSelect<T, Prisma__deckClient<deck>, Prisma__deckClient<deckGetPayload<T>>>

    /**
     * Find one Deck that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {deckFindUniqueOrThrowArgs} args - Arguments to find a Deck
     * @example
     * // Get one Deck
     * const deck = await prisma.deck.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends deckFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, deckFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__deckClient<deck>, Prisma__deckClient<deckGetPayload<T>>>

    /**
     * Find the first Deck that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deckFindFirstOrThrowArgs} args - Arguments to find a Deck
     * @example
     * // Get one Deck
     * const deck = await prisma.deck.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends deckFindFirstOrThrowArgs>(
      args?: SelectSubset<T, deckFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__deckClient<deck>, Prisma__deckClient<deckGetPayload<T>>>

    /**
     * Count the number of Decks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deckCountArgs} args - Arguments to filter Decks to count.
     * @example
     * // Count the number of Decks
     * const count = await prisma.deck.count({
     *   where: {
     *     // ... the filter for the Decks we want to count
     *   }
     * })
    **/
    count<T extends deckCountArgs>(
      args?: Subset<T, deckCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeckCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Deck.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeckAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeckAggregateArgs>(args: Subset<T, DeckAggregateArgs>): PrismaPromise<GetDeckAggregateType<T>>

    /**
     * Group by Deck.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeckGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeckGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeckGroupByArgs['orderBy'] }
        : { orderBy?: DeckGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeckGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeckGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for deck.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__deckClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    card<T extends cardArgs = {}>(args?: Subset<T, cardArgs>): CheckSelect<T, Prisma__cardClient<card | Null>, Prisma__cardClient<cardGetPayload<T> | Null>>;

    usuario<T extends usuarioArgs = {}>(args?: Subset<T, usuarioArgs>): CheckSelect<T, Prisma__usuarioClient<usuario | Null>, Prisma__usuarioClient<usuarioGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * deck base type for findUnique actions
   */
  export type deckFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the deck
     * 
    **/
    select?: deckSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: deckInclude | null
    /**
     * Filter, which deck to fetch.
     * 
    **/
    where: deckWhereUniqueInput
  }

  /**
   * deck: findUnique
   */
  export interface deckFindUniqueArgs extends deckFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * deck base type for findFirst actions
   */
  export type deckFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the deck
     * 
    **/
    select?: deckSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: deckInclude | null
    /**
     * Filter, which deck to fetch.
     * 
    **/
    where?: deckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of decks to fetch.
     * 
    **/
    orderBy?: Enumerable<deckOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for decks.
     * 
    **/
    cursor?: deckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` decks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` decks.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of decks.
     * 
    **/
    distinct?: Enumerable<DeckScalarFieldEnum>
  }

  /**
   * deck: findFirst
   */
  export interface deckFindFirstArgs extends deckFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * deck findMany
   */
  export type deckFindManyArgs = {
    /**
     * Select specific fields to fetch from the deck
     * 
    **/
    select?: deckSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: deckInclude | null
    /**
     * Filter, which decks to fetch.
     * 
    **/
    where?: deckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of decks to fetch.
     * 
    **/
    orderBy?: Enumerable<deckOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing decks.
     * 
    **/
    cursor?: deckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` decks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` decks.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DeckScalarFieldEnum>
  }


  /**
   * deck create
   */
  export type deckCreateArgs = {
    /**
     * Select specific fields to fetch from the deck
     * 
    **/
    select?: deckSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: deckInclude | null
    /**
     * The data needed to create a deck.
     * 
    **/
    data: XOR<deckCreateInput, deckUncheckedCreateInput>
  }


  /**
   * deck createMany
   */
  export type deckCreateManyArgs = {
    /**
     * The data used to create many decks.
     * 
    **/
    data: Enumerable<deckCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * deck update
   */
  export type deckUpdateArgs = {
    /**
     * Select specific fields to fetch from the deck
     * 
    **/
    select?: deckSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: deckInclude | null
    /**
     * The data needed to update a deck.
     * 
    **/
    data: XOR<deckUpdateInput, deckUncheckedUpdateInput>
    /**
     * Choose, which deck to update.
     * 
    **/
    where: deckWhereUniqueInput
  }


  /**
   * deck updateMany
   */
  export type deckUpdateManyArgs = {
    /**
     * The data used to update decks.
     * 
    **/
    data: XOR<deckUpdateManyMutationInput, deckUncheckedUpdateManyInput>
    /**
     * Filter which decks to update
     * 
    **/
    where?: deckWhereInput
  }


  /**
   * deck upsert
   */
  export type deckUpsertArgs = {
    /**
     * Select specific fields to fetch from the deck
     * 
    **/
    select?: deckSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: deckInclude | null
    /**
     * The filter to search for the deck to update in case it exists.
     * 
    **/
    where: deckWhereUniqueInput
    /**
     * In case the deck found by the `where` argument doesn't exist, create a new deck with this data.
     * 
    **/
    create: XOR<deckCreateInput, deckUncheckedCreateInput>
    /**
     * In case the deck was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<deckUpdateInput, deckUncheckedUpdateInput>
  }


  /**
   * deck delete
   */
  export type deckDeleteArgs = {
    /**
     * Select specific fields to fetch from the deck
     * 
    **/
    select?: deckSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: deckInclude | null
    /**
     * Filter which deck to delete.
     * 
    **/
    where: deckWhereUniqueInput
  }


  /**
   * deck deleteMany
   */
  export type deckDeleteManyArgs = {
    /**
     * Filter which decks to delete
     * 
    **/
    where?: deckWhereInput
  }


  /**
   * deck: findUniqueOrThrow
   */
  export type deckFindUniqueOrThrowArgs = deckFindUniqueArgsBase
      

  /**
   * deck: findFirstOrThrow
   */
  export type deckFindFirstOrThrowArgs = deckFindFirstArgsBase
      

  /**
   * deck without action
   */
  export type deckArgs = {
    /**
     * Select specific fields to fetch from the deck
     * 
    **/
    select?: deckSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: deckInclude | null
  }



  /**
   * Model inimigo
   */


  export type AggregateInimigo = {
    _count: InimigoCountAggregateOutputType | null
    _avg: InimigoAvgAggregateOutputType | null
    _sum: InimigoSumAggregateOutputType | null
    _min: InimigoMinAggregateOutputType | null
    _max: InimigoMaxAggregateOutputType | null
  }

  export type InimigoAvgAggregateOutputType = {
    id: number | null
    fase: number | null
    idUsuario: number | null
    idInimigos: number | null
    poder: number | null
    vida: number | null
  }

  export type InimigoSumAggregateOutputType = {
    id: number | null
    fase: number | null
    idUsuario: number | null
    idInimigos: number | null
    poder: number | null
    vida: number | null
  }

  export type InimigoMinAggregateOutputType = {
    id: number | null
    nome: string | null
    foto: string | null
    fase: number | null
    idUsuario: number | null
    idInimigos: number | null
    poder: number | null
    vida: number | null
  }

  export type InimigoMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    foto: string | null
    fase: number | null
    idUsuario: number | null
    idInimigos: number | null
    poder: number | null
    vida: number | null
  }

  export type InimigoCountAggregateOutputType = {
    id: number
    nome: number
    foto: number
    fase: number
    idUsuario: number
    idInimigos: number
    poder: number
    vida: number
    _all: number
  }


  export type InimigoAvgAggregateInputType = {
    id?: true
    fase?: true
    idUsuario?: true
    idInimigos?: true
    poder?: true
    vida?: true
  }

  export type InimigoSumAggregateInputType = {
    id?: true
    fase?: true
    idUsuario?: true
    idInimigos?: true
    poder?: true
    vida?: true
  }

  export type InimigoMinAggregateInputType = {
    id?: true
    nome?: true
    foto?: true
    fase?: true
    idUsuario?: true
    idInimigos?: true
    poder?: true
    vida?: true
  }

  export type InimigoMaxAggregateInputType = {
    id?: true
    nome?: true
    foto?: true
    fase?: true
    idUsuario?: true
    idInimigos?: true
    poder?: true
    vida?: true
  }

  export type InimigoCountAggregateInputType = {
    id?: true
    nome?: true
    foto?: true
    fase?: true
    idUsuario?: true
    idInimigos?: true
    poder?: true
    vida?: true
    _all?: true
  }

  export type InimigoAggregateArgs = {
    /**
     * Filter which inimigo to aggregate.
     * 
    **/
    where?: inimigoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inimigos to fetch.
     * 
    **/
    orderBy?: Enumerable<inimigoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: inimigoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inimigos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inimigos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inimigos
    **/
    _count?: true | InimigoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InimigoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InimigoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InimigoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InimigoMaxAggregateInputType
  }

  export type GetInimigoAggregateType<T extends InimigoAggregateArgs> = {
        [P in keyof T & keyof AggregateInimigo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInimigo[P]>
      : GetScalarType<T[P], AggregateInimigo[P]>
  }




  export type InimigoGroupByArgs = {
    where?: inimigoWhereInput
    orderBy?: Enumerable<inimigoOrderByWithAggregationInput>
    by: Array<InimigoScalarFieldEnum>
    having?: inimigoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InimigoCountAggregateInputType | true
    _avg?: InimigoAvgAggregateInputType
    _sum?: InimigoSumAggregateInputType
    _min?: InimigoMinAggregateInputType
    _max?: InimigoMaxAggregateInputType
  }


  export type InimigoGroupByOutputType = {
    id: number
    nome: string
    foto: string
    fase: number
    idUsuario: number
    idInimigos: number
    poder: number
    vida: number
    _count: InimigoCountAggregateOutputType | null
    _avg: InimigoAvgAggregateOutputType | null
    _sum: InimigoSumAggregateOutputType | null
    _min: InimigoMinAggregateOutputType | null
    _max: InimigoMaxAggregateOutputType | null
  }

  type GetInimigoGroupByPayload<T extends InimigoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<InimigoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InimigoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InimigoGroupByOutputType[P]>
            : GetScalarType<T[P], InimigoGroupByOutputType[P]>
        }
      >
    >


  export type inimigoSelect = {
    id?: boolean
    nome?: boolean
    foto?: boolean
    fase?: boolean
    idUsuario?: boolean
    idInimigos?: boolean
    poder?: boolean
    vida?: boolean
    inimigos?: boolean | inimigosArgs
    usuario?: boolean | usuarioArgs
  }

  export type inimigoInclude = {
    inimigos?: boolean | inimigosArgs
    usuario?: boolean | usuarioArgs
  }

  export type inimigoGetPayload<
    S extends boolean | null | undefined | inimigoArgs,
    U = keyof S
      > = S extends true
        ? inimigo
    : S extends undefined
    ? never
    : S extends inimigoArgs | inimigoFindManyArgs
    ?'include' extends U
    ? inimigo  & {
    [P in TrueKeys<S['include']>]:
        P extends 'inimigos' ? inimigosGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'usuario' ? usuarioGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'inimigos' ? inimigosGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'usuario' ? usuarioGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof inimigo ? inimigo[P] : never
  } 
    : inimigo
  : inimigo


  type inimigoCountArgs = Merge<
    Omit<inimigoFindManyArgs, 'select' | 'include'> & {
      select?: InimigoCountAggregateInputType | true
    }
  >

  export interface inimigoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Inimigo that matches the filter.
     * @param {inimigoFindUniqueArgs} args - Arguments to find a Inimigo
     * @example
     * // Get one Inimigo
     * const inimigo = await prisma.inimigo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inimigoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, inimigoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'inimigo'> extends True ? CheckSelect<T, Prisma__inimigoClient<inimigo>, Prisma__inimigoClient<inimigoGetPayload<T>>> : CheckSelect<T, Prisma__inimigoClient<inimigo | null, null>, Prisma__inimigoClient<inimigoGetPayload<T> | null, null>>

    /**
     * Find the first Inimigo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inimigoFindFirstArgs} args - Arguments to find a Inimigo
     * @example
     * // Get one Inimigo
     * const inimigo = await prisma.inimigo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inimigoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, inimigoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'inimigo'> extends True ? CheckSelect<T, Prisma__inimigoClient<inimigo>, Prisma__inimigoClient<inimigoGetPayload<T>>> : CheckSelect<T, Prisma__inimigoClient<inimigo | null, null>, Prisma__inimigoClient<inimigoGetPayload<T> | null, null>>

    /**
     * Find zero or more Inimigos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inimigoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inimigos
     * const inimigos = await prisma.inimigo.findMany()
     * 
     * // Get first 10 Inimigos
     * const inimigos = await prisma.inimigo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inimigoWithIdOnly = await prisma.inimigo.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends inimigoFindManyArgs>(
      args?: SelectSubset<T, inimigoFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<inimigo>>, PrismaPromise<Array<inimigoGetPayload<T>>>>

    /**
     * Create a Inimigo.
     * @param {inimigoCreateArgs} args - Arguments to create a Inimigo.
     * @example
     * // Create one Inimigo
     * const Inimigo = await prisma.inimigo.create({
     *   data: {
     *     // ... data to create a Inimigo
     *   }
     * })
     * 
    **/
    create<T extends inimigoCreateArgs>(
      args: SelectSubset<T, inimigoCreateArgs>
    ): CheckSelect<T, Prisma__inimigoClient<inimigo>, Prisma__inimigoClient<inimigoGetPayload<T>>>

    /**
     * Create many Inimigos.
     *     @param {inimigoCreateManyArgs} args - Arguments to create many Inimigos.
     *     @example
     *     // Create many Inimigos
     *     const inimigo = await prisma.inimigo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inimigoCreateManyArgs>(
      args?: SelectSubset<T, inimigoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Inimigo.
     * @param {inimigoDeleteArgs} args - Arguments to delete one Inimigo.
     * @example
     * // Delete one Inimigo
     * const Inimigo = await prisma.inimigo.delete({
     *   where: {
     *     // ... filter to delete one Inimigo
     *   }
     * })
     * 
    **/
    delete<T extends inimigoDeleteArgs>(
      args: SelectSubset<T, inimigoDeleteArgs>
    ): CheckSelect<T, Prisma__inimigoClient<inimigo>, Prisma__inimigoClient<inimigoGetPayload<T>>>

    /**
     * Update one Inimigo.
     * @param {inimigoUpdateArgs} args - Arguments to update one Inimigo.
     * @example
     * // Update one Inimigo
     * const inimigo = await prisma.inimigo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inimigoUpdateArgs>(
      args: SelectSubset<T, inimigoUpdateArgs>
    ): CheckSelect<T, Prisma__inimigoClient<inimigo>, Prisma__inimigoClient<inimigoGetPayload<T>>>

    /**
     * Delete zero or more Inimigos.
     * @param {inimigoDeleteManyArgs} args - Arguments to filter Inimigos to delete.
     * @example
     * // Delete a few Inimigos
     * const { count } = await prisma.inimigo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inimigoDeleteManyArgs>(
      args?: SelectSubset<T, inimigoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inimigos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inimigoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inimigos
     * const inimigo = await prisma.inimigo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inimigoUpdateManyArgs>(
      args: SelectSubset<T, inimigoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Inimigo.
     * @param {inimigoUpsertArgs} args - Arguments to update or create a Inimigo.
     * @example
     * // Update or create a Inimigo
     * const inimigo = await prisma.inimigo.upsert({
     *   create: {
     *     // ... data to create a Inimigo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inimigo we want to update
     *   }
     * })
    **/
    upsert<T extends inimigoUpsertArgs>(
      args: SelectSubset<T, inimigoUpsertArgs>
    ): CheckSelect<T, Prisma__inimigoClient<inimigo>, Prisma__inimigoClient<inimigoGetPayload<T>>>

    /**
     * Find one Inimigo that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {inimigoFindUniqueOrThrowArgs} args - Arguments to find a Inimigo
     * @example
     * // Get one Inimigo
     * const inimigo = await prisma.inimigo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inimigoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, inimigoFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__inimigoClient<inimigo>, Prisma__inimigoClient<inimigoGetPayload<T>>>

    /**
     * Find the first Inimigo that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inimigoFindFirstOrThrowArgs} args - Arguments to find a Inimigo
     * @example
     * // Get one Inimigo
     * const inimigo = await prisma.inimigo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inimigoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, inimigoFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__inimigoClient<inimigo>, Prisma__inimigoClient<inimigoGetPayload<T>>>

    /**
     * Count the number of Inimigos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inimigoCountArgs} args - Arguments to filter Inimigos to count.
     * @example
     * // Count the number of Inimigos
     * const count = await prisma.inimigo.count({
     *   where: {
     *     // ... the filter for the Inimigos we want to count
     *   }
     * })
    **/
    count<T extends inimigoCountArgs>(
      args?: Subset<T, inimigoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InimigoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inimigo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InimigoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InimigoAggregateArgs>(args: Subset<T, InimigoAggregateArgs>): PrismaPromise<GetInimigoAggregateType<T>>

    /**
     * Group by Inimigo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InimigoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InimigoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InimigoGroupByArgs['orderBy'] }
        : { orderBy?: InimigoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InimigoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInimigoGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for inimigo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__inimigoClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    inimigos<T extends inimigosArgs = {}>(args?: Subset<T, inimigosArgs>): CheckSelect<T, Prisma__inimigosClient<inimigos | Null>, Prisma__inimigosClient<inimigosGetPayload<T> | Null>>;

    usuario<T extends usuarioArgs = {}>(args?: Subset<T, usuarioArgs>): CheckSelect<T, Prisma__usuarioClient<usuario | Null>, Prisma__usuarioClient<usuarioGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * inimigo base type for findUnique actions
   */
  export type inimigoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the inimigo
     * 
    **/
    select?: inimigoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: inimigoInclude | null
    /**
     * Filter, which inimigo to fetch.
     * 
    **/
    where: inimigoWhereUniqueInput
  }

  /**
   * inimigo: findUnique
   */
  export interface inimigoFindUniqueArgs extends inimigoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * inimigo base type for findFirst actions
   */
  export type inimigoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the inimigo
     * 
    **/
    select?: inimigoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: inimigoInclude | null
    /**
     * Filter, which inimigo to fetch.
     * 
    **/
    where?: inimigoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inimigos to fetch.
     * 
    **/
    orderBy?: Enumerable<inimigoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inimigos.
     * 
    **/
    cursor?: inimigoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inimigos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inimigos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inimigos.
     * 
    **/
    distinct?: Enumerable<InimigoScalarFieldEnum>
  }

  /**
   * inimigo: findFirst
   */
  export interface inimigoFindFirstArgs extends inimigoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * inimigo findMany
   */
  export type inimigoFindManyArgs = {
    /**
     * Select specific fields to fetch from the inimigo
     * 
    **/
    select?: inimigoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: inimigoInclude | null
    /**
     * Filter, which inimigos to fetch.
     * 
    **/
    where?: inimigoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inimigos to fetch.
     * 
    **/
    orderBy?: Enumerable<inimigoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inimigos.
     * 
    **/
    cursor?: inimigoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inimigos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inimigos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<InimigoScalarFieldEnum>
  }


  /**
   * inimigo create
   */
  export type inimigoCreateArgs = {
    /**
     * Select specific fields to fetch from the inimigo
     * 
    **/
    select?: inimigoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: inimigoInclude | null
    /**
     * The data needed to create a inimigo.
     * 
    **/
    data: XOR<inimigoCreateInput, inimigoUncheckedCreateInput>
  }


  /**
   * inimigo createMany
   */
  export type inimigoCreateManyArgs = {
    /**
     * The data used to create many inimigos.
     * 
    **/
    data: Enumerable<inimigoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * inimigo update
   */
  export type inimigoUpdateArgs = {
    /**
     * Select specific fields to fetch from the inimigo
     * 
    **/
    select?: inimigoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: inimigoInclude | null
    /**
     * The data needed to update a inimigo.
     * 
    **/
    data: XOR<inimigoUpdateInput, inimigoUncheckedUpdateInput>
    /**
     * Choose, which inimigo to update.
     * 
    **/
    where: inimigoWhereUniqueInput
  }


  /**
   * inimigo updateMany
   */
  export type inimigoUpdateManyArgs = {
    /**
     * The data used to update inimigos.
     * 
    **/
    data: XOR<inimigoUpdateManyMutationInput, inimigoUncheckedUpdateManyInput>
    /**
     * Filter which inimigos to update
     * 
    **/
    where?: inimigoWhereInput
  }


  /**
   * inimigo upsert
   */
  export type inimigoUpsertArgs = {
    /**
     * Select specific fields to fetch from the inimigo
     * 
    **/
    select?: inimigoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: inimigoInclude | null
    /**
     * The filter to search for the inimigo to update in case it exists.
     * 
    **/
    where: inimigoWhereUniqueInput
    /**
     * In case the inimigo found by the `where` argument doesn't exist, create a new inimigo with this data.
     * 
    **/
    create: XOR<inimigoCreateInput, inimigoUncheckedCreateInput>
    /**
     * In case the inimigo was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<inimigoUpdateInput, inimigoUncheckedUpdateInput>
  }


  /**
   * inimigo delete
   */
  export type inimigoDeleteArgs = {
    /**
     * Select specific fields to fetch from the inimigo
     * 
    **/
    select?: inimigoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: inimigoInclude | null
    /**
     * Filter which inimigo to delete.
     * 
    **/
    where: inimigoWhereUniqueInput
  }


  /**
   * inimigo deleteMany
   */
  export type inimigoDeleteManyArgs = {
    /**
     * Filter which inimigos to delete
     * 
    **/
    where?: inimigoWhereInput
  }


  /**
   * inimigo: findUniqueOrThrow
   */
  export type inimigoFindUniqueOrThrowArgs = inimigoFindUniqueArgsBase
      

  /**
   * inimigo: findFirstOrThrow
   */
  export type inimigoFindFirstOrThrowArgs = inimigoFindFirstArgsBase
      

  /**
   * inimigo without action
   */
  export type inimigoArgs = {
    /**
     * Select specific fields to fetch from the inimigo
     * 
    **/
    select?: inimigoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: inimigoInclude | null
  }



  /**
   * Model card
   */


  export type AggregateCard = {
    _count: CardCountAggregateOutputType | null
    _avg: CardAvgAggregateOutputType | null
    _sum: CardSumAggregateOutputType | null
    _min: CardMinAggregateOutputType | null
    _max: CardMaxAggregateOutputType | null
  }

  export type CardAvgAggregateOutputType = {
    id: number | null
    poder: number | null
    vida: number | null
  }

  export type CardSumAggregateOutputType = {
    id: number | null
    poder: number | null
    vida: number | null
  }

  export type CardMinAggregateOutputType = {
    id: number | null
    foto: string | null
    poder: number | null
    vida: number | null
    nome: string | null
  }

  export type CardMaxAggregateOutputType = {
    id: number | null
    foto: string | null
    poder: number | null
    vida: number | null
    nome: string | null
  }

  export type CardCountAggregateOutputType = {
    id: number
    foto: number
    poder: number
    vida: number
    nome: number
    _all: number
  }


  export type CardAvgAggregateInputType = {
    id?: true
    poder?: true
    vida?: true
  }

  export type CardSumAggregateInputType = {
    id?: true
    poder?: true
    vida?: true
  }

  export type CardMinAggregateInputType = {
    id?: true
    foto?: true
    poder?: true
    vida?: true
    nome?: true
  }

  export type CardMaxAggregateInputType = {
    id?: true
    foto?: true
    poder?: true
    vida?: true
    nome?: true
  }

  export type CardCountAggregateInputType = {
    id?: true
    foto?: true
    poder?: true
    vida?: true
    nome?: true
    _all?: true
  }

  export type CardAggregateArgs = {
    /**
     * Filter which card to aggregate.
     * 
    **/
    where?: cardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cards to fetch.
     * 
    **/
    orderBy?: Enumerable<cardOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: cardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cards from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cards.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cards
    **/
    _count?: true | CardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CardMaxAggregateInputType
  }

  export type GetCardAggregateType<T extends CardAggregateArgs> = {
        [P in keyof T & keyof AggregateCard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCard[P]>
      : GetScalarType<T[P], AggregateCard[P]>
  }




  export type CardGroupByArgs = {
    where?: cardWhereInput
    orderBy?: Enumerable<cardOrderByWithAggregationInput>
    by: Array<CardScalarFieldEnum>
    having?: cardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CardCountAggregateInputType | true
    _avg?: CardAvgAggregateInputType
    _sum?: CardSumAggregateInputType
    _min?: CardMinAggregateInputType
    _max?: CardMaxAggregateInputType
  }


  export type CardGroupByOutputType = {
    id: number
    foto: string
    poder: number
    vida: number
    nome: string
    _count: CardCountAggregateOutputType | null
    _avg: CardAvgAggregateOutputType | null
    _sum: CardSumAggregateOutputType | null
    _min: CardMinAggregateOutputType | null
    _max: CardMaxAggregateOutputType | null
  }

  type GetCardGroupByPayload<T extends CardGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CardGroupByOutputType[P]>
            : GetScalarType<T[P], CardGroupByOutputType[P]>
        }
      >
    >


  export type cardSelect = {
    id?: boolean
    foto?: boolean
    poder?: boolean
    vida?: boolean
    nome?: boolean
    deck?: boolean | deckFindManyArgs
    ouroCard?: boolean | ouroCardFindManyArgs
    _count?: boolean | CardCountOutputTypeArgs
  }

  export type cardInclude = {
    deck?: boolean | deckFindManyArgs
    ouroCard?: boolean | ouroCardFindManyArgs
    _count?: boolean | CardCountOutputTypeArgs
  }

  export type cardGetPayload<
    S extends boolean | null | undefined | cardArgs,
    U = keyof S
      > = S extends true
        ? card
    : S extends undefined
    ? never
    : S extends cardArgs | cardFindManyArgs
    ?'include' extends U
    ? card  & {
    [P in TrueKeys<S['include']>]:
        P extends 'deck' ? Array < deckGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'ouroCard' ? Array < ouroCardGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? CardCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'deck' ? Array < deckGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'ouroCard' ? Array < ouroCardGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? CardCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof card ? card[P] : never
  } 
    : card
  : card


  type cardCountArgs = Merge<
    Omit<cardFindManyArgs, 'select' | 'include'> & {
      select?: CardCountAggregateInputType | true
    }
  >

  export interface cardDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Card that matches the filter.
     * @param {cardFindUniqueArgs} args - Arguments to find a Card
     * @example
     * // Get one Card
     * const card = await prisma.card.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends cardFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, cardFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'card'> extends True ? CheckSelect<T, Prisma__cardClient<card>, Prisma__cardClient<cardGetPayload<T>>> : CheckSelect<T, Prisma__cardClient<card | null, null>, Prisma__cardClient<cardGetPayload<T> | null, null>>

    /**
     * Find the first Card that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cardFindFirstArgs} args - Arguments to find a Card
     * @example
     * // Get one Card
     * const card = await prisma.card.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends cardFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, cardFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'card'> extends True ? CheckSelect<T, Prisma__cardClient<card>, Prisma__cardClient<cardGetPayload<T>>> : CheckSelect<T, Prisma__cardClient<card | null, null>, Prisma__cardClient<cardGetPayload<T> | null, null>>

    /**
     * Find zero or more Cards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cardFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cards
     * const cards = await prisma.card.findMany()
     * 
     * // Get first 10 Cards
     * const cards = await prisma.card.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cardWithIdOnly = await prisma.card.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends cardFindManyArgs>(
      args?: SelectSubset<T, cardFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<card>>, PrismaPromise<Array<cardGetPayload<T>>>>

    /**
     * Create a Card.
     * @param {cardCreateArgs} args - Arguments to create a Card.
     * @example
     * // Create one Card
     * const Card = await prisma.card.create({
     *   data: {
     *     // ... data to create a Card
     *   }
     * })
     * 
    **/
    create<T extends cardCreateArgs>(
      args: SelectSubset<T, cardCreateArgs>
    ): CheckSelect<T, Prisma__cardClient<card>, Prisma__cardClient<cardGetPayload<T>>>

    /**
     * Create many Cards.
     *     @param {cardCreateManyArgs} args - Arguments to create many Cards.
     *     @example
     *     // Create many Cards
     *     const card = await prisma.card.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends cardCreateManyArgs>(
      args?: SelectSubset<T, cardCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Card.
     * @param {cardDeleteArgs} args - Arguments to delete one Card.
     * @example
     * // Delete one Card
     * const Card = await prisma.card.delete({
     *   where: {
     *     // ... filter to delete one Card
     *   }
     * })
     * 
    **/
    delete<T extends cardDeleteArgs>(
      args: SelectSubset<T, cardDeleteArgs>
    ): CheckSelect<T, Prisma__cardClient<card>, Prisma__cardClient<cardGetPayload<T>>>

    /**
     * Update one Card.
     * @param {cardUpdateArgs} args - Arguments to update one Card.
     * @example
     * // Update one Card
     * const card = await prisma.card.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends cardUpdateArgs>(
      args: SelectSubset<T, cardUpdateArgs>
    ): CheckSelect<T, Prisma__cardClient<card>, Prisma__cardClient<cardGetPayload<T>>>

    /**
     * Delete zero or more Cards.
     * @param {cardDeleteManyArgs} args - Arguments to filter Cards to delete.
     * @example
     * // Delete a few Cards
     * const { count } = await prisma.card.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends cardDeleteManyArgs>(
      args?: SelectSubset<T, cardDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cards
     * const card = await prisma.card.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends cardUpdateManyArgs>(
      args: SelectSubset<T, cardUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Card.
     * @param {cardUpsertArgs} args - Arguments to update or create a Card.
     * @example
     * // Update or create a Card
     * const card = await prisma.card.upsert({
     *   create: {
     *     // ... data to create a Card
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Card we want to update
     *   }
     * })
    **/
    upsert<T extends cardUpsertArgs>(
      args: SelectSubset<T, cardUpsertArgs>
    ): CheckSelect<T, Prisma__cardClient<card>, Prisma__cardClient<cardGetPayload<T>>>

    /**
     * Find one Card that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {cardFindUniqueOrThrowArgs} args - Arguments to find a Card
     * @example
     * // Get one Card
     * const card = await prisma.card.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends cardFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, cardFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__cardClient<card>, Prisma__cardClient<cardGetPayload<T>>>

    /**
     * Find the first Card that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cardFindFirstOrThrowArgs} args - Arguments to find a Card
     * @example
     * // Get one Card
     * const card = await prisma.card.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends cardFindFirstOrThrowArgs>(
      args?: SelectSubset<T, cardFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__cardClient<card>, Prisma__cardClient<cardGetPayload<T>>>

    /**
     * Count the number of Cards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cardCountArgs} args - Arguments to filter Cards to count.
     * @example
     * // Count the number of Cards
     * const count = await prisma.card.count({
     *   where: {
     *     // ... the filter for the Cards we want to count
     *   }
     * })
    **/
    count<T extends cardCountArgs>(
      args?: Subset<T, cardCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Card.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CardAggregateArgs>(args: Subset<T, CardAggregateArgs>): PrismaPromise<GetCardAggregateType<T>>

    /**
     * Group by Card.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CardGroupByArgs['orderBy'] }
        : { orderBy?: CardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCardGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for card.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__cardClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    deck<T extends deckFindManyArgs = {}>(args?: Subset<T, deckFindManyArgs>): CheckSelect<T, PrismaPromise<Array<deck>| Null>, PrismaPromise<Array<deckGetPayload<T>>| Null>>;

    ouroCard<T extends ouroCardFindManyArgs = {}>(args?: Subset<T, ouroCardFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ouroCard>| Null>, PrismaPromise<Array<ouroCardGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * card base type for findUnique actions
   */
  export type cardFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the card
     * 
    **/
    select?: cardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cardInclude | null
    /**
     * Filter, which card to fetch.
     * 
    **/
    where: cardWhereUniqueInput
  }

  /**
   * card: findUnique
   */
  export interface cardFindUniqueArgs extends cardFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * card base type for findFirst actions
   */
  export type cardFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the card
     * 
    **/
    select?: cardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cardInclude | null
    /**
     * Filter, which card to fetch.
     * 
    **/
    where?: cardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cards to fetch.
     * 
    **/
    orderBy?: Enumerable<cardOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cards.
     * 
    **/
    cursor?: cardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cards from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cards.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cards.
     * 
    **/
    distinct?: Enumerable<CardScalarFieldEnum>
  }

  /**
   * card: findFirst
   */
  export interface cardFindFirstArgs extends cardFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * card findMany
   */
  export type cardFindManyArgs = {
    /**
     * Select specific fields to fetch from the card
     * 
    **/
    select?: cardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cardInclude | null
    /**
     * Filter, which cards to fetch.
     * 
    **/
    where?: cardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cards to fetch.
     * 
    **/
    orderBy?: Enumerable<cardOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cards.
     * 
    **/
    cursor?: cardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cards from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cards.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CardScalarFieldEnum>
  }


  /**
   * card create
   */
  export type cardCreateArgs = {
    /**
     * Select specific fields to fetch from the card
     * 
    **/
    select?: cardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cardInclude | null
    /**
     * The data needed to create a card.
     * 
    **/
    data: XOR<cardCreateInput, cardUncheckedCreateInput>
  }


  /**
   * card createMany
   */
  export type cardCreateManyArgs = {
    /**
     * The data used to create many cards.
     * 
    **/
    data: Enumerable<cardCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * card update
   */
  export type cardUpdateArgs = {
    /**
     * Select specific fields to fetch from the card
     * 
    **/
    select?: cardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cardInclude | null
    /**
     * The data needed to update a card.
     * 
    **/
    data: XOR<cardUpdateInput, cardUncheckedUpdateInput>
    /**
     * Choose, which card to update.
     * 
    **/
    where: cardWhereUniqueInput
  }


  /**
   * card updateMany
   */
  export type cardUpdateManyArgs = {
    /**
     * The data used to update cards.
     * 
    **/
    data: XOR<cardUpdateManyMutationInput, cardUncheckedUpdateManyInput>
    /**
     * Filter which cards to update
     * 
    **/
    where?: cardWhereInput
  }


  /**
   * card upsert
   */
  export type cardUpsertArgs = {
    /**
     * Select specific fields to fetch from the card
     * 
    **/
    select?: cardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cardInclude | null
    /**
     * The filter to search for the card to update in case it exists.
     * 
    **/
    where: cardWhereUniqueInput
    /**
     * In case the card found by the `where` argument doesn't exist, create a new card with this data.
     * 
    **/
    create: XOR<cardCreateInput, cardUncheckedCreateInput>
    /**
     * In case the card was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<cardUpdateInput, cardUncheckedUpdateInput>
  }


  /**
   * card delete
   */
  export type cardDeleteArgs = {
    /**
     * Select specific fields to fetch from the card
     * 
    **/
    select?: cardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cardInclude | null
    /**
     * Filter which card to delete.
     * 
    **/
    where: cardWhereUniqueInput
  }


  /**
   * card deleteMany
   */
  export type cardDeleteManyArgs = {
    /**
     * Filter which cards to delete
     * 
    **/
    where?: cardWhereInput
  }


  /**
   * card: findUniqueOrThrow
   */
  export type cardFindUniqueOrThrowArgs = cardFindUniqueArgsBase
      

  /**
   * card: findFirstOrThrow
   */
  export type cardFindFirstOrThrowArgs = cardFindFirstArgsBase
      

  /**
   * card without action
   */
  export type cardArgs = {
    /**
     * Select specific fields to fetch from the card
     * 
    **/
    select?: cardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cardInclude | null
  }



  /**
   * Model usuario
   */


  export type AggregateUsuario = {
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  export type UsuarioAvgAggregateOutputType = {
    id: number | null
    fase: number | null
  }

  export type UsuarioSumAggregateOutputType = {
    id: number | null
    fase: number | null
  }

  export type UsuarioMinAggregateOutputType = {
    id: number | null
    token: string | null
    senha: string | null
    email: string | null
    foto: string | null
    nome: string | null
    fase: number | null
  }

  export type UsuarioMaxAggregateOutputType = {
    id: number | null
    token: string | null
    senha: string | null
    email: string | null
    foto: string | null
    nome: string | null
    fase: number | null
  }

  export type UsuarioCountAggregateOutputType = {
    id: number
    token: number
    senha: number
    email: number
    foto: number
    nome: number
    fase: number
    _all: number
  }


  export type UsuarioAvgAggregateInputType = {
    id?: true
    fase?: true
  }

  export type UsuarioSumAggregateInputType = {
    id?: true
    fase?: true
  }

  export type UsuarioMinAggregateInputType = {
    id?: true
    token?: true
    senha?: true
    email?: true
    foto?: true
    nome?: true
    fase?: true
  }

  export type UsuarioMaxAggregateInputType = {
    id?: true
    token?: true
    senha?: true
    email?: true
    foto?: true
    nome?: true
    fase?: true
  }

  export type UsuarioCountAggregateInputType = {
    id?: true
    token?: true
    senha?: true
    email?: true
    foto?: true
    nome?: true
    fase?: true
    _all?: true
  }

  export type UsuarioAggregateArgs = {
    /**
     * Filter which usuario to aggregate.
     * 
    **/
    where?: usuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios to fetch.
     * 
    **/
    orderBy?: Enumerable<usuarioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: usuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned usuarios
    **/
    _count?: true | UsuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuarioMaxAggregateInputType
  }

  export type GetUsuarioAggregateType<T extends UsuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario[P]>
      : GetScalarType<T[P], AggregateUsuario[P]>
  }




  export type UsuarioGroupByArgs = {
    where?: usuarioWhereInput
    orderBy?: Enumerable<usuarioOrderByWithAggregationInput>
    by: Array<UsuarioScalarFieldEnum>
    having?: usuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuarioCountAggregateInputType | true
    _avg?: UsuarioAvgAggregateInputType
    _sum?: UsuarioSumAggregateInputType
    _min?: UsuarioMinAggregateInputType
    _max?: UsuarioMaxAggregateInputType
  }


  export type UsuarioGroupByOutputType = {
    id: number
    token: string
    senha: string
    email: string
    foto: string
    nome: string
    fase: number
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  type GetUsuarioGroupByPayload<T extends UsuarioGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UsuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
        }
      >
    >


  export type usuarioSelect = {
    id?: boolean
    token?: boolean
    senha?: boolean
    email?: boolean
    foto?: boolean
    nome?: boolean
    fase?: boolean
    deck?: boolean | deckFindManyArgs
    inimigo?: boolean | inimigoFindManyArgs
    ouro?: boolean | ouroFindManyArgs
    vitorias?: boolean | vitoriasFindManyArgs
    _count?: boolean | UsuarioCountOutputTypeArgs
  }

  export type usuarioInclude = {
    deck?: boolean | deckFindManyArgs
    inimigo?: boolean | inimigoFindManyArgs
    ouro?: boolean | ouroFindManyArgs
    vitorias?: boolean | vitoriasFindManyArgs
    _count?: boolean | UsuarioCountOutputTypeArgs
  }

  export type usuarioGetPayload<
    S extends boolean | null | undefined | usuarioArgs,
    U = keyof S
      > = S extends true
        ? usuario
    : S extends undefined
    ? never
    : S extends usuarioArgs | usuarioFindManyArgs
    ?'include' extends U
    ? usuario  & {
    [P in TrueKeys<S['include']>]:
        P extends 'deck' ? Array < deckGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'inimigo' ? Array < inimigoGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'ouro' ? Array < ouroGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'vitorias' ? Array < vitoriasGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? UsuarioCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'deck' ? Array < deckGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'inimigo' ? Array < inimigoGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'ouro' ? Array < ouroGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'vitorias' ? Array < vitoriasGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? UsuarioCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof usuario ? usuario[P] : never
  } 
    : usuario
  : usuario


  type usuarioCountArgs = Merge<
    Omit<usuarioFindManyArgs, 'select' | 'include'> & {
      select?: UsuarioCountAggregateInputType | true
    }
  >

  export interface usuarioDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Usuario that matches the filter.
     * @param {usuarioFindUniqueArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends usuarioFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, usuarioFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'usuario'> extends True ? CheckSelect<T, Prisma__usuarioClient<usuario>, Prisma__usuarioClient<usuarioGetPayload<T>>> : CheckSelect<T, Prisma__usuarioClient<usuario | null, null>, Prisma__usuarioClient<usuarioGetPayload<T> | null, null>>

    /**
     * Find the first Usuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioFindFirstArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends usuarioFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, usuarioFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'usuario'> extends True ? CheckSelect<T, Prisma__usuarioClient<usuario>, Prisma__usuarioClient<usuarioGetPayload<T>>> : CheckSelect<T, Prisma__usuarioClient<usuario | null, null>, Prisma__usuarioClient<usuarioGetPayload<T> | null, null>>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuario.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usuarioWithIdOnly = await prisma.usuario.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends usuarioFindManyArgs>(
      args?: SelectSubset<T, usuarioFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<usuario>>, PrismaPromise<Array<usuarioGetPayload<T>>>>

    /**
     * Create a Usuario.
     * @param {usuarioCreateArgs} args - Arguments to create a Usuario.
     * @example
     * // Create one Usuario
     * const Usuario = await prisma.usuario.create({
     *   data: {
     *     // ... data to create a Usuario
     *   }
     * })
     * 
    **/
    create<T extends usuarioCreateArgs>(
      args: SelectSubset<T, usuarioCreateArgs>
    ): CheckSelect<T, Prisma__usuarioClient<usuario>, Prisma__usuarioClient<usuarioGetPayload<T>>>

    /**
     * Create many Usuarios.
     *     @param {usuarioCreateManyArgs} args - Arguments to create many Usuarios.
     *     @example
     *     // Create many Usuarios
     *     const usuario = await prisma.usuario.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends usuarioCreateManyArgs>(
      args?: SelectSubset<T, usuarioCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Usuario.
     * @param {usuarioDeleteArgs} args - Arguments to delete one Usuario.
     * @example
     * // Delete one Usuario
     * const Usuario = await prisma.usuario.delete({
     *   where: {
     *     // ... filter to delete one Usuario
     *   }
     * })
     * 
    **/
    delete<T extends usuarioDeleteArgs>(
      args: SelectSubset<T, usuarioDeleteArgs>
    ): CheckSelect<T, Prisma__usuarioClient<usuario>, Prisma__usuarioClient<usuarioGetPayload<T>>>

    /**
     * Update one Usuario.
     * @param {usuarioUpdateArgs} args - Arguments to update one Usuario.
     * @example
     * // Update one Usuario
     * const usuario = await prisma.usuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends usuarioUpdateArgs>(
      args: SelectSubset<T, usuarioUpdateArgs>
    ): CheckSelect<T, Prisma__usuarioClient<usuario>, Prisma__usuarioClient<usuarioGetPayload<T>>>

    /**
     * Delete zero or more Usuarios.
     * @param {usuarioDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends usuarioDeleteManyArgs>(
      args?: SelectSubset<T, usuarioDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends usuarioUpdateManyArgs>(
      args: SelectSubset<T, usuarioUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Usuario.
     * @param {usuarioUpsertArgs} args - Arguments to update or create a Usuario.
     * @example
     * // Update or create a Usuario
     * const usuario = await prisma.usuario.upsert({
     *   create: {
     *     // ... data to create a Usuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario we want to update
     *   }
     * })
    **/
    upsert<T extends usuarioUpsertArgs>(
      args: SelectSubset<T, usuarioUpsertArgs>
    ): CheckSelect<T, Prisma__usuarioClient<usuario>, Prisma__usuarioClient<usuarioGetPayload<T>>>

    /**
     * Find one Usuario that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {usuarioFindUniqueOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends usuarioFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, usuarioFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__usuarioClient<usuario>, Prisma__usuarioClient<usuarioGetPayload<T>>>

    /**
     * Find the first Usuario that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioFindFirstOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends usuarioFindFirstOrThrowArgs>(
      args?: SelectSubset<T, usuarioFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__usuarioClient<usuario>, Prisma__usuarioClient<usuarioGetPayload<T>>>

    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuario.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends usuarioCountArgs>(
      args?: Subset<T, usuarioCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuarioAggregateArgs>(args: Subset<T, UsuarioAggregateArgs>): PrismaPromise<GetUsuarioAggregateType<T>>

    /**
     * Group by Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuarioGroupByArgs['orderBy'] }
        : { orderBy?: UsuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuarioGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for usuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__usuarioClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    deck<T extends deckFindManyArgs = {}>(args?: Subset<T, deckFindManyArgs>): CheckSelect<T, PrismaPromise<Array<deck>| Null>, PrismaPromise<Array<deckGetPayload<T>>| Null>>;

    inimigo<T extends inimigoFindManyArgs = {}>(args?: Subset<T, inimigoFindManyArgs>): CheckSelect<T, PrismaPromise<Array<inimigo>| Null>, PrismaPromise<Array<inimigoGetPayload<T>>| Null>>;

    ouro<T extends ouroFindManyArgs = {}>(args?: Subset<T, ouroFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ouro>| Null>, PrismaPromise<Array<ouroGetPayload<T>>| Null>>;

    vitorias<T extends vitoriasFindManyArgs = {}>(args?: Subset<T, vitoriasFindManyArgs>): CheckSelect<T, PrismaPromise<Array<vitorias>| Null>, PrismaPromise<Array<vitoriasGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * usuario base type for findUnique actions
   */
  export type usuarioFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the usuario
     * 
    **/
    select?: usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usuarioInclude | null
    /**
     * Filter, which usuario to fetch.
     * 
    **/
    where: usuarioWhereUniqueInput
  }

  /**
   * usuario: findUnique
   */
  export interface usuarioFindUniqueArgs extends usuarioFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * usuario base type for findFirst actions
   */
  export type usuarioFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the usuario
     * 
    **/
    select?: usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usuarioInclude | null
    /**
     * Filter, which usuario to fetch.
     * 
    **/
    where?: usuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios to fetch.
     * 
    **/
    orderBy?: Enumerable<usuarioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usuarios.
     * 
    **/
    cursor?: usuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usuarios.
     * 
    **/
    distinct?: Enumerable<UsuarioScalarFieldEnum>
  }

  /**
   * usuario: findFirst
   */
  export interface usuarioFindFirstArgs extends usuarioFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * usuario findMany
   */
  export type usuarioFindManyArgs = {
    /**
     * Select specific fields to fetch from the usuario
     * 
    **/
    select?: usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usuarioInclude | null
    /**
     * Filter, which usuarios to fetch.
     * 
    **/
    where?: usuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios to fetch.
     * 
    **/
    orderBy?: Enumerable<usuarioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing usuarios.
     * 
    **/
    cursor?: usuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UsuarioScalarFieldEnum>
  }


  /**
   * usuario create
   */
  export type usuarioCreateArgs = {
    /**
     * Select specific fields to fetch from the usuario
     * 
    **/
    select?: usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usuarioInclude | null
    /**
     * The data needed to create a usuario.
     * 
    **/
    data: XOR<usuarioCreateInput, usuarioUncheckedCreateInput>
  }


  /**
   * usuario createMany
   */
  export type usuarioCreateManyArgs = {
    /**
     * The data used to create many usuarios.
     * 
    **/
    data: Enumerable<usuarioCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * usuario update
   */
  export type usuarioUpdateArgs = {
    /**
     * Select specific fields to fetch from the usuario
     * 
    **/
    select?: usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usuarioInclude | null
    /**
     * The data needed to update a usuario.
     * 
    **/
    data: XOR<usuarioUpdateInput, usuarioUncheckedUpdateInput>
    /**
     * Choose, which usuario to update.
     * 
    **/
    where: usuarioWhereUniqueInput
  }


  /**
   * usuario updateMany
   */
  export type usuarioUpdateManyArgs = {
    /**
     * The data used to update usuarios.
     * 
    **/
    data: XOR<usuarioUpdateManyMutationInput, usuarioUncheckedUpdateManyInput>
    /**
     * Filter which usuarios to update
     * 
    **/
    where?: usuarioWhereInput
  }


  /**
   * usuario upsert
   */
  export type usuarioUpsertArgs = {
    /**
     * Select specific fields to fetch from the usuario
     * 
    **/
    select?: usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usuarioInclude | null
    /**
     * The filter to search for the usuario to update in case it exists.
     * 
    **/
    where: usuarioWhereUniqueInput
    /**
     * In case the usuario found by the `where` argument doesn't exist, create a new usuario with this data.
     * 
    **/
    create: XOR<usuarioCreateInput, usuarioUncheckedCreateInput>
    /**
     * In case the usuario was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<usuarioUpdateInput, usuarioUncheckedUpdateInput>
  }


  /**
   * usuario delete
   */
  export type usuarioDeleteArgs = {
    /**
     * Select specific fields to fetch from the usuario
     * 
    **/
    select?: usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usuarioInclude | null
    /**
     * Filter which usuario to delete.
     * 
    **/
    where: usuarioWhereUniqueInput
  }


  /**
   * usuario deleteMany
   */
  export type usuarioDeleteManyArgs = {
    /**
     * Filter which usuarios to delete
     * 
    **/
    where?: usuarioWhereInput
  }


  /**
   * usuario: findUniqueOrThrow
   */
  export type usuarioFindUniqueOrThrowArgs = usuarioFindUniqueArgsBase
      

  /**
   * usuario: findFirstOrThrow
   */
  export type usuarioFindFirstOrThrowArgs = usuarioFindFirstArgsBase
      

  /**
   * usuario without action
   */
  export type usuarioArgs = {
    /**
     * Select specific fields to fetch from the usuario
     * 
    **/
    select?: usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usuarioInclude | null
  }



  /**
   * Model inimigos
   */


  export type AggregateInimigos = {
    _count: InimigosCountAggregateOutputType | null
    _avg: InimigosAvgAggregateOutputType | null
    _sum: InimigosSumAggregateOutputType | null
    _min: InimigosMinAggregateOutputType | null
    _max: InimigosMaxAggregateOutputType | null
  }

  export type InimigosAvgAggregateOutputType = {
    id: number | null
    poder: number | null
    vida: number | null
    fase: number | null
  }

  export type InimigosSumAggregateOutputType = {
    id: number | null
    poder: number | null
    vida: number | null
    fase: number | null
  }

  export type InimigosMinAggregateOutputType = {
    id: number | null
    poder: number | null
    nome: string | null
    foto: string | null
    vida: number | null
    fase: number | null
  }

  export type InimigosMaxAggregateOutputType = {
    id: number | null
    poder: number | null
    nome: string | null
    foto: string | null
    vida: number | null
    fase: number | null
  }

  export type InimigosCountAggregateOutputType = {
    id: number
    poder: number
    nome: number
    foto: number
    vida: number
    fase: number
    _all: number
  }


  export type InimigosAvgAggregateInputType = {
    id?: true
    poder?: true
    vida?: true
    fase?: true
  }

  export type InimigosSumAggregateInputType = {
    id?: true
    poder?: true
    vida?: true
    fase?: true
  }

  export type InimigosMinAggregateInputType = {
    id?: true
    poder?: true
    nome?: true
    foto?: true
    vida?: true
    fase?: true
  }

  export type InimigosMaxAggregateInputType = {
    id?: true
    poder?: true
    nome?: true
    foto?: true
    vida?: true
    fase?: true
  }

  export type InimigosCountAggregateInputType = {
    id?: true
    poder?: true
    nome?: true
    foto?: true
    vida?: true
    fase?: true
    _all?: true
  }

  export type InimigosAggregateArgs = {
    /**
     * Filter which inimigos to aggregate.
     * 
    **/
    where?: inimigosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inimigos to fetch.
     * 
    **/
    orderBy?: Enumerable<inimigosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: inimigosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inimigos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inimigos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inimigos
    **/
    _count?: true | InimigosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InimigosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InimigosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InimigosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InimigosMaxAggregateInputType
  }

  export type GetInimigosAggregateType<T extends InimigosAggregateArgs> = {
        [P in keyof T & keyof AggregateInimigos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInimigos[P]>
      : GetScalarType<T[P], AggregateInimigos[P]>
  }




  export type InimigosGroupByArgs = {
    where?: inimigosWhereInput
    orderBy?: Enumerable<inimigosOrderByWithAggregationInput>
    by: Array<InimigosScalarFieldEnum>
    having?: inimigosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InimigosCountAggregateInputType | true
    _avg?: InimigosAvgAggregateInputType
    _sum?: InimigosSumAggregateInputType
    _min?: InimigosMinAggregateInputType
    _max?: InimigosMaxAggregateInputType
  }


  export type InimigosGroupByOutputType = {
    id: number
    poder: number
    nome: string
    foto: string
    vida: number
    fase: number
    _count: InimigosCountAggregateOutputType | null
    _avg: InimigosAvgAggregateOutputType | null
    _sum: InimigosSumAggregateOutputType | null
    _min: InimigosMinAggregateOutputType | null
    _max: InimigosMaxAggregateOutputType | null
  }

  type GetInimigosGroupByPayload<T extends InimigosGroupByArgs> = PrismaPromise<
    Array<
      PickArray<InimigosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InimigosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InimigosGroupByOutputType[P]>
            : GetScalarType<T[P], InimigosGroupByOutputType[P]>
        }
      >
    >


  export type inimigosSelect = {
    id?: boolean
    poder?: boolean
    nome?: boolean
    foto?: boolean
    vida?: boolean
    fase?: boolean
    inimigo?: boolean | inimigoFindManyArgs
    _count?: boolean | InimigosCountOutputTypeArgs
  }

  export type inimigosInclude = {
    inimigo?: boolean | inimigoFindManyArgs
    _count?: boolean | InimigosCountOutputTypeArgs
  }

  export type inimigosGetPayload<
    S extends boolean | null | undefined | inimigosArgs,
    U = keyof S
      > = S extends true
        ? inimigos
    : S extends undefined
    ? never
    : S extends inimigosArgs | inimigosFindManyArgs
    ?'include' extends U
    ? inimigos  & {
    [P in TrueKeys<S['include']>]:
        P extends 'inimigo' ? Array < inimigoGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? InimigosCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'inimigo' ? Array < inimigoGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? InimigosCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof inimigos ? inimigos[P] : never
  } 
    : inimigos
  : inimigos


  type inimigosCountArgs = Merge<
    Omit<inimigosFindManyArgs, 'select' | 'include'> & {
      select?: InimigosCountAggregateInputType | true
    }
  >

  export interface inimigosDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Inimigos that matches the filter.
     * @param {inimigosFindUniqueArgs} args - Arguments to find a Inimigos
     * @example
     * // Get one Inimigos
     * const inimigos = await prisma.inimigos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends inimigosFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, inimigosFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'inimigos'> extends True ? CheckSelect<T, Prisma__inimigosClient<inimigos>, Prisma__inimigosClient<inimigosGetPayload<T>>> : CheckSelect<T, Prisma__inimigosClient<inimigos | null, null>, Prisma__inimigosClient<inimigosGetPayload<T> | null, null>>

    /**
     * Find the first Inimigos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inimigosFindFirstArgs} args - Arguments to find a Inimigos
     * @example
     * // Get one Inimigos
     * const inimigos = await prisma.inimigos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends inimigosFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, inimigosFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'inimigos'> extends True ? CheckSelect<T, Prisma__inimigosClient<inimigos>, Prisma__inimigosClient<inimigosGetPayload<T>>> : CheckSelect<T, Prisma__inimigosClient<inimigos | null, null>, Prisma__inimigosClient<inimigosGetPayload<T> | null, null>>

    /**
     * Find zero or more Inimigos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inimigosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inimigos
     * const inimigos = await prisma.inimigos.findMany()
     * 
     * // Get first 10 Inimigos
     * const inimigos = await prisma.inimigos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inimigosWithIdOnly = await prisma.inimigos.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends inimigosFindManyArgs>(
      args?: SelectSubset<T, inimigosFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<inimigos>>, PrismaPromise<Array<inimigosGetPayload<T>>>>

    /**
     * Create a Inimigos.
     * @param {inimigosCreateArgs} args - Arguments to create a Inimigos.
     * @example
     * // Create one Inimigos
     * const Inimigos = await prisma.inimigos.create({
     *   data: {
     *     // ... data to create a Inimigos
     *   }
     * })
     * 
    **/
    create<T extends inimigosCreateArgs>(
      args: SelectSubset<T, inimigosCreateArgs>
    ): CheckSelect<T, Prisma__inimigosClient<inimigos>, Prisma__inimigosClient<inimigosGetPayload<T>>>

    /**
     * Create many Inimigos.
     *     @param {inimigosCreateManyArgs} args - Arguments to create many Inimigos.
     *     @example
     *     // Create many Inimigos
     *     const inimigos = await prisma.inimigos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends inimigosCreateManyArgs>(
      args?: SelectSubset<T, inimigosCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Inimigos.
     * @param {inimigosDeleteArgs} args - Arguments to delete one Inimigos.
     * @example
     * // Delete one Inimigos
     * const Inimigos = await prisma.inimigos.delete({
     *   where: {
     *     // ... filter to delete one Inimigos
     *   }
     * })
     * 
    **/
    delete<T extends inimigosDeleteArgs>(
      args: SelectSubset<T, inimigosDeleteArgs>
    ): CheckSelect<T, Prisma__inimigosClient<inimigos>, Prisma__inimigosClient<inimigosGetPayload<T>>>

    /**
     * Update one Inimigos.
     * @param {inimigosUpdateArgs} args - Arguments to update one Inimigos.
     * @example
     * // Update one Inimigos
     * const inimigos = await prisma.inimigos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends inimigosUpdateArgs>(
      args: SelectSubset<T, inimigosUpdateArgs>
    ): CheckSelect<T, Prisma__inimigosClient<inimigos>, Prisma__inimigosClient<inimigosGetPayload<T>>>

    /**
     * Delete zero or more Inimigos.
     * @param {inimigosDeleteManyArgs} args - Arguments to filter Inimigos to delete.
     * @example
     * // Delete a few Inimigos
     * const { count } = await prisma.inimigos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends inimigosDeleteManyArgs>(
      args?: SelectSubset<T, inimigosDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inimigos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inimigosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inimigos
     * const inimigos = await prisma.inimigos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends inimigosUpdateManyArgs>(
      args: SelectSubset<T, inimigosUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Inimigos.
     * @param {inimigosUpsertArgs} args - Arguments to update or create a Inimigos.
     * @example
     * // Update or create a Inimigos
     * const inimigos = await prisma.inimigos.upsert({
     *   create: {
     *     // ... data to create a Inimigos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inimigos we want to update
     *   }
     * })
    **/
    upsert<T extends inimigosUpsertArgs>(
      args: SelectSubset<T, inimigosUpsertArgs>
    ): CheckSelect<T, Prisma__inimigosClient<inimigos>, Prisma__inimigosClient<inimigosGetPayload<T>>>

    /**
     * Find one Inimigos that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {inimigosFindUniqueOrThrowArgs} args - Arguments to find a Inimigos
     * @example
     * // Get one Inimigos
     * const inimigos = await prisma.inimigos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends inimigosFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, inimigosFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__inimigosClient<inimigos>, Prisma__inimigosClient<inimigosGetPayload<T>>>

    /**
     * Find the first Inimigos that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inimigosFindFirstOrThrowArgs} args - Arguments to find a Inimigos
     * @example
     * // Get one Inimigos
     * const inimigos = await prisma.inimigos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends inimigosFindFirstOrThrowArgs>(
      args?: SelectSubset<T, inimigosFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__inimigosClient<inimigos>, Prisma__inimigosClient<inimigosGetPayload<T>>>

    /**
     * Count the number of Inimigos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inimigosCountArgs} args - Arguments to filter Inimigos to count.
     * @example
     * // Count the number of Inimigos
     * const count = await prisma.inimigos.count({
     *   where: {
     *     // ... the filter for the Inimigos we want to count
     *   }
     * })
    **/
    count<T extends inimigosCountArgs>(
      args?: Subset<T, inimigosCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InimigosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inimigos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InimigosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InimigosAggregateArgs>(args: Subset<T, InimigosAggregateArgs>): PrismaPromise<GetInimigosAggregateType<T>>

    /**
     * Group by Inimigos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InimigosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InimigosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InimigosGroupByArgs['orderBy'] }
        : { orderBy?: InimigosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InimigosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInimigosGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for inimigos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__inimigosClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    inimigo<T extends inimigoFindManyArgs = {}>(args?: Subset<T, inimigoFindManyArgs>): CheckSelect<T, PrismaPromise<Array<inimigo>| Null>, PrismaPromise<Array<inimigoGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * inimigos base type for findUnique actions
   */
  export type inimigosFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the inimigos
     * 
    **/
    select?: inimigosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: inimigosInclude | null
    /**
     * Filter, which inimigos to fetch.
     * 
    **/
    where: inimigosWhereUniqueInput
  }

  /**
   * inimigos: findUnique
   */
  export interface inimigosFindUniqueArgs extends inimigosFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * inimigos base type for findFirst actions
   */
  export type inimigosFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the inimigos
     * 
    **/
    select?: inimigosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: inimigosInclude | null
    /**
     * Filter, which inimigos to fetch.
     * 
    **/
    where?: inimigosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inimigos to fetch.
     * 
    **/
    orderBy?: Enumerable<inimigosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inimigos.
     * 
    **/
    cursor?: inimigosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inimigos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inimigos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inimigos.
     * 
    **/
    distinct?: Enumerable<InimigosScalarFieldEnum>
  }

  /**
   * inimigos: findFirst
   */
  export interface inimigosFindFirstArgs extends inimigosFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * inimigos findMany
   */
  export type inimigosFindManyArgs = {
    /**
     * Select specific fields to fetch from the inimigos
     * 
    **/
    select?: inimigosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: inimigosInclude | null
    /**
     * Filter, which inimigos to fetch.
     * 
    **/
    where?: inimigosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inimigos to fetch.
     * 
    **/
    orderBy?: Enumerable<inimigosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inimigos.
     * 
    **/
    cursor?: inimigosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inimigos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inimigos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<InimigosScalarFieldEnum>
  }


  /**
   * inimigos create
   */
  export type inimigosCreateArgs = {
    /**
     * Select specific fields to fetch from the inimigos
     * 
    **/
    select?: inimigosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: inimigosInclude | null
    /**
     * The data needed to create a inimigos.
     * 
    **/
    data: XOR<inimigosCreateInput, inimigosUncheckedCreateInput>
  }


  /**
   * inimigos createMany
   */
  export type inimigosCreateManyArgs = {
    /**
     * The data used to create many inimigos.
     * 
    **/
    data: Enumerable<inimigosCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * inimigos update
   */
  export type inimigosUpdateArgs = {
    /**
     * Select specific fields to fetch from the inimigos
     * 
    **/
    select?: inimigosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: inimigosInclude | null
    /**
     * The data needed to update a inimigos.
     * 
    **/
    data: XOR<inimigosUpdateInput, inimigosUncheckedUpdateInput>
    /**
     * Choose, which inimigos to update.
     * 
    **/
    where: inimigosWhereUniqueInput
  }


  /**
   * inimigos updateMany
   */
  export type inimigosUpdateManyArgs = {
    /**
     * The data used to update inimigos.
     * 
    **/
    data: XOR<inimigosUpdateManyMutationInput, inimigosUncheckedUpdateManyInput>
    /**
     * Filter which inimigos to update
     * 
    **/
    where?: inimigosWhereInput
  }


  /**
   * inimigos upsert
   */
  export type inimigosUpsertArgs = {
    /**
     * Select specific fields to fetch from the inimigos
     * 
    **/
    select?: inimigosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: inimigosInclude | null
    /**
     * The filter to search for the inimigos to update in case it exists.
     * 
    **/
    where: inimigosWhereUniqueInput
    /**
     * In case the inimigos found by the `where` argument doesn't exist, create a new inimigos with this data.
     * 
    **/
    create: XOR<inimigosCreateInput, inimigosUncheckedCreateInput>
    /**
     * In case the inimigos was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<inimigosUpdateInput, inimigosUncheckedUpdateInput>
  }


  /**
   * inimigos delete
   */
  export type inimigosDeleteArgs = {
    /**
     * Select specific fields to fetch from the inimigos
     * 
    **/
    select?: inimigosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: inimigosInclude | null
    /**
     * Filter which inimigos to delete.
     * 
    **/
    where: inimigosWhereUniqueInput
  }


  /**
   * inimigos deleteMany
   */
  export type inimigosDeleteManyArgs = {
    /**
     * Filter which inimigos to delete
     * 
    **/
    where?: inimigosWhereInput
  }


  /**
   * inimigos: findUniqueOrThrow
   */
  export type inimigosFindUniqueOrThrowArgs = inimigosFindUniqueArgsBase
      

  /**
   * inimigos: findFirstOrThrow
   */
  export type inimigosFindFirstOrThrowArgs = inimigosFindFirstArgsBase
      

  /**
   * inimigos without action
   */
  export type inimigosArgs = {
    /**
     * Select specific fields to fetch from the inimigos
     * 
    **/
    select?: inimigosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: inimigosInclude | null
  }



  /**
   * Model vitorias
   */


  export type AggregateVitorias = {
    _count: VitoriasCountAggregateOutputType | null
    _avg: VitoriasAvgAggregateOutputType | null
    _sum: VitoriasSumAggregateOutputType | null
    _min: VitoriasMinAggregateOutputType | null
    _max: VitoriasMaxAggregateOutputType | null
  }

  export type VitoriasAvgAggregateOutputType = {
    id: number | null
    vitorias: number | null
    usuarioId: number | null
  }

  export type VitoriasSumAggregateOutputType = {
    id: number | null
    vitorias: number | null
    usuarioId: number | null
  }

  export type VitoriasMinAggregateOutputType = {
    id: number | null
    vitorias: number | null
    usuarioId: number | null
  }

  export type VitoriasMaxAggregateOutputType = {
    id: number | null
    vitorias: number | null
    usuarioId: number | null
  }

  export type VitoriasCountAggregateOutputType = {
    id: number
    vitorias: number
    usuarioId: number
    _all: number
  }


  export type VitoriasAvgAggregateInputType = {
    id?: true
    vitorias?: true
    usuarioId?: true
  }

  export type VitoriasSumAggregateInputType = {
    id?: true
    vitorias?: true
    usuarioId?: true
  }

  export type VitoriasMinAggregateInputType = {
    id?: true
    vitorias?: true
    usuarioId?: true
  }

  export type VitoriasMaxAggregateInputType = {
    id?: true
    vitorias?: true
    usuarioId?: true
  }

  export type VitoriasCountAggregateInputType = {
    id?: true
    vitorias?: true
    usuarioId?: true
    _all?: true
  }

  export type VitoriasAggregateArgs = {
    /**
     * Filter which vitorias to aggregate.
     * 
    **/
    where?: vitoriasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vitorias to fetch.
     * 
    **/
    orderBy?: Enumerable<vitoriasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: vitoriasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vitorias from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vitorias.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned vitorias
    **/
    _count?: true | VitoriasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VitoriasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VitoriasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VitoriasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VitoriasMaxAggregateInputType
  }

  export type GetVitoriasAggregateType<T extends VitoriasAggregateArgs> = {
        [P in keyof T & keyof AggregateVitorias]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVitorias[P]>
      : GetScalarType<T[P], AggregateVitorias[P]>
  }




  export type VitoriasGroupByArgs = {
    where?: vitoriasWhereInput
    orderBy?: Enumerable<vitoriasOrderByWithAggregationInput>
    by: Array<VitoriasScalarFieldEnum>
    having?: vitoriasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VitoriasCountAggregateInputType | true
    _avg?: VitoriasAvgAggregateInputType
    _sum?: VitoriasSumAggregateInputType
    _min?: VitoriasMinAggregateInputType
    _max?: VitoriasMaxAggregateInputType
  }


  export type VitoriasGroupByOutputType = {
    id: number
    vitorias: number
    usuarioId: number
    _count: VitoriasCountAggregateOutputType | null
    _avg: VitoriasAvgAggregateOutputType | null
    _sum: VitoriasSumAggregateOutputType | null
    _min: VitoriasMinAggregateOutputType | null
    _max: VitoriasMaxAggregateOutputType | null
  }

  type GetVitoriasGroupByPayload<T extends VitoriasGroupByArgs> = PrismaPromise<
    Array<
      PickArray<VitoriasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VitoriasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VitoriasGroupByOutputType[P]>
            : GetScalarType<T[P], VitoriasGroupByOutputType[P]>
        }
      >
    >


  export type vitoriasSelect = {
    id?: boolean
    vitorias?: boolean
    usuarioId?: boolean
    usuario?: boolean | usuarioArgs
  }

  export type vitoriasInclude = {
    usuario?: boolean | usuarioArgs
  }

  export type vitoriasGetPayload<
    S extends boolean | null | undefined | vitoriasArgs,
    U = keyof S
      > = S extends true
        ? vitorias
    : S extends undefined
    ? never
    : S extends vitoriasArgs | vitoriasFindManyArgs
    ?'include' extends U
    ? vitorias  & {
    [P in TrueKeys<S['include']>]:
        P extends 'usuario' ? usuarioGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'usuario' ? usuarioGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof vitorias ? vitorias[P] : never
  } 
    : vitorias
  : vitorias


  type vitoriasCountArgs = Merge<
    Omit<vitoriasFindManyArgs, 'select' | 'include'> & {
      select?: VitoriasCountAggregateInputType | true
    }
  >

  export interface vitoriasDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Vitorias that matches the filter.
     * @param {vitoriasFindUniqueArgs} args - Arguments to find a Vitorias
     * @example
     * // Get one Vitorias
     * const vitorias = await prisma.vitorias.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends vitoriasFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, vitoriasFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'vitorias'> extends True ? CheckSelect<T, Prisma__vitoriasClient<vitorias>, Prisma__vitoriasClient<vitoriasGetPayload<T>>> : CheckSelect<T, Prisma__vitoriasClient<vitorias | null, null>, Prisma__vitoriasClient<vitoriasGetPayload<T> | null, null>>

    /**
     * Find the first Vitorias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vitoriasFindFirstArgs} args - Arguments to find a Vitorias
     * @example
     * // Get one Vitorias
     * const vitorias = await prisma.vitorias.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends vitoriasFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, vitoriasFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'vitorias'> extends True ? CheckSelect<T, Prisma__vitoriasClient<vitorias>, Prisma__vitoriasClient<vitoriasGetPayload<T>>> : CheckSelect<T, Prisma__vitoriasClient<vitorias | null, null>, Prisma__vitoriasClient<vitoriasGetPayload<T> | null, null>>

    /**
     * Find zero or more Vitorias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vitoriasFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vitorias
     * const vitorias = await prisma.vitorias.findMany()
     * 
     * // Get first 10 Vitorias
     * const vitorias = await prisma.vitorias.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vitoriasWithIdOnly = await prisma.vitorias.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends vitoriasFindManyArgs>(
      args?: SelectSubset<T, vitoriasFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<vitorias>>, PrismaPromise<Array<vitoriasGetPayload<T>>>>

    /**
     * Create a Vitorias.
     * @param {vitoriasCreateArgs} args - Arguments to create a Vitorias.
     * @example
     * // Create one Vitorias
     * const Vitorias = await prisma.vitorias.create({
     *   data: {
     *     // ... data to create a Vitorias
     *   }
     * })
     * 
    **/
    create<T extends vitoriasCreateArgs>(
      args: SelectSubset<T, vitoriasCreateArgs>
    ): CheckSelect<T, Prisma__vitoriasClient<vitorias>, Prisma__vitoriasClient<vitoriasGetPayload<T>>>

    /**
     * Create many Vitorias.
     *     @param {vitoriasCreateManyArgs} args - Arguments to create many Vitorias.
     *     @example
     *     // Create many Vitorias
     *     const vitorias = await prisma.vitorias.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends vitoriasCreateManyArgs>(
      args?: SelectSubset<T, vitoriasCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Vitorias.
     * @param {vitoriasDeleteArgs} args - Arguments to delete one Vitorias.
     * @example
     * // Delete one Vitorias
     * const Vitorias = await prisma.vitorias.delete({
     *   where: {
     *     // ... filter to delete one Vitorias
     *   }
     * })
     * 
    **/
    delete<T extends vitoriasDeleteArgs>(
      args: SelectSubset<T, vitoriasDeleteArgs>
    ): CheckSelect<T, Prisma__vitoriasClient<vitorias>, Prisma__vitoriasClient<vitoriasGetPayload<T>>>

    /**
     * Update one Vitorias.
     * @param {vitoriasUpdateArgs} args - Arguments to update one Vitorias.
     * @example
     * // Update one Vitorias
     * const vitorias = await prisma.vitorias.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends vitoriasUpdateArgs>(
      args: SelectSubset<T, vitoriasUpdateArgs>
    ): CheckSelect<T, Prisma__vitoriasClient<vitorias>, Prisma__vitoriasClient<vitoriasGetPayload<T>>>

    /**
     * Delete zero or more Vitorias.
     * @param {vitoriasDeleteManyArgs} args - Arguments to filter Vitorias to delete.
     * @example
     * // Delete a few Vitorias
     * const { count } = await prisma.vitorias.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends vitoriasDeleteManyArgs>(
      args?: SelectSubset<T, vitoriasDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vitorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vitoriasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vitorias
     * const vitorias = await prisma.vitorias.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends vitoriasUpdateManyArgs>(
      args: SelectSubset<T, vitoriasUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Vitorias.
     * @param {vitoriasUpsertArgs} args - Arguments to update or create a Vitorias.
     * @example
     * // Update or create a Vitorias
     * const vitorias = await prisma.vitorias.upsert({
     *   create: {
     *     // ... data to create a Vitorias
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vitorias we want to update
     *   }
     * })
    **/
    upsert<T extends vitoriasUpsertArgs>(
      args: SelectSubset<T, vitoriasUpsertArgs>
    ): CheckSelect<T, Prisma__vitoriasClient<vitorias>, Prisma__vitoriasClient<vitoriasGetPayload<T>>>

    /**
     * Find one Vitorias that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {vitoriasFindUniqueOrThrowArgs} args - Arguments to find a Vitorias
     * @example
     * // Get one Vitorias
     * const vitorias = await prisma.vitorias.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends vitoriasFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, vitoriasFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__vitoriasClient<vitorias>, Prisma__vitoriasClient<vitoriasGetPayload<T>>>

    /**
     * Find the first Vitorias that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vitoriasFindFirstOrThrowArgs} args - Arguments to find a Vitorias
     * @example
     * // Get one Vitorias
     * const vitorias = await prisma.vitorias.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends vitoriasFindFirstOrThrowArgs>(
      args?: SelectSubset<T, vitoriasFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__vitoriasClient<vitorias>, Prisma__vitoriasClient<vitoriasGetPayload<T>>>

    /**
     * Count the number of Vitorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vitoriasCountArgs} args - Arguments to filter Vitorias to count.
     * @example
     * // Count the number of Vitorias
     * const count = await prisma.vitorias.count({
     *   where: {
     *     // ... the filter for the Vitorias we want to count
     *   }
     * })
    **/
    count<T extends vitoriasCountArgs>(
      args?: Subset<T, vitoriasCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VitoriasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vitorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitoriasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VitoriasAggregateArgs>(args: Subset<T, VitoriasAggregateArgs>): PrismaPromise<GetVitoriasAggregateType<T>>

    /**
     * Group by Vitorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitoriasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VitoriasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VitoriasGroupByArgs['orderBy'] }
        : { orderBy?: VitoriasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VitoriasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVitoriasGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for vitorias.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__vitoriasClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    usuario<T extends usuarioArgs = {}>(args?: Subset<T, usuarioArgs>): CheckSelect<T, Prisma__usuarioClient<usuario | Null>, Prisma__usuarioClient<usuarioGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * vitorias base type for findUnique actions
   */
  export type vitoriasFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the vitorias
     * 
    **/
    select?: vitoriasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: vitoriasInclude | null
    /**
     * Filter, which vitorias to fetch.
     * 
    **/
    where: vitoriasWhereUniqueInput
  }

  /**
   * vitorias: findUnique
   */
  export interface vitoriasFindUniqueArgs extends vitoriasFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * vitorias base type for findFirst actions
   */
  export type vitoriasFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the vitorias
     * 
    **/
    select?: vitoriasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: vitoriasInclude | null
    /**
     * Filter, which vitorias to fetch.
     * 
    **/
    where?: vitoriasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vitorias to fetch.
     * 
    **/
    orderBy?: Enumerable<vitoriasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vitorias.
     * 
    **/
    cursor?: vitoriasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vitorias from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vitorias.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vitorias.
     * 
    **/
    distinct?: Enumerable<VitoriasScalarFieldEnum>
  }

  /**
   * vitorias: findFirst
   */
  export interface vitoriasFindFirstArgs extends vitoriasFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * vitorias findMany
   */
  export type vitoriasFindManyArgs = {
    /**
     * Select specific fields to fetch from the vitorias
     * 
    **/
    select?: vitoriasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: vitoriasInclude | null
    /**
     * Filter, which vitorias to fetch.
     * 
    **/
    where?: vitoriasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vitorias to fetch.
     * 
    **/
    orderBy?: Enumerable<vitoriasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing vitorias.
     * 
    **/
    cursor?: vitoriasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vitorias from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vitorias.
     * 
    **/
    skip?: number
    distinct?: Enumerable<VitoriasScalarFieldEnum>
  }


  /**
   * vitorias create
   */
  export type vitoriasCreateArgs = {
    /**
     * Select specific fields to fetch from the vitorias
     * 
    **/
    select?: vitoriasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: vitoriasInclude | null
    /**
     * The data needed to create a vitorias.
     * 
    **/
    data: XOR<vitoriasCreateInput, vitoriasUncheckedCreateInput>
  }


  /**
   * vitorias createMany
   */
  export type vitoriasCreateManyArgs = {
    /**
     * The data used to create many vitorias.
     * 
    **/
    data: Enumerable<vitoriasCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * vitorias update
   */
  export type vitoriasUpdateArgs = {
    /**
     * Select specific fields to fetch from the vitorias
     * 
    **/
    select?: vitoriasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: vitoriasInclude | null
    /**
     * The data needed to update a vitorias.
     * 
    **/
    data: XOR<vitoriasUpdateInput, vitoriasUncheckedUpdateInput>
    /**
     * Choose, which vitorias to update.
     * 
    **/
    where: vitoriasWhereUniqueInput
  }


  /**
   * vitorias updateMany
   */
  export type vitoriasUpdateManyArgs = {
    /**
     * The data used to update vitorias.
     * 
    **/
    data: XOR<vitoriasUpdateManyMutationInput, vitoriasUncheckedUpdateManyInput>
    /**
     * Filter which vitorias to update
     * 
    **/
    where?: vitoriasWhereInput
  }


  /**
   * vitorias upsert
   */
  export type vitoriasUpsertArgs = {
    /**
     * Select specific fields to fetch from the vitorias
     * 
    **/
    select?: vitoriasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: vitoriasInclude | null
    /**
     * The filter to search for the vitorias to update in case it exists.
     * 
    **/
    where: vitoriasWhereUniqueInput
    /**
     * In case the vitorias found by the `where` argument doesn't exist, create a new vitorias with this data.
     * 
    **/
    create: XOR<vitoriasCreateInput, vitoriasUncheckedCreateInput>
    /**
     * In case the vitorias was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<vitoriasUpdateInput, vitoriasUncheckedUpdateInput>
  }


  /**
   * vitorias delete
   */
  export type vitoriasDeleteArgs = {
    /**
     * Select specific fields to fetch from the vitorias
     * 
    **/
    select?: vitoriasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: vitoriasInclude | null
    /**
     * Filter which vitorias to delete.
     * 
    **/
    where: vitoriasWhereUniqueInput
  }


  /**
   * vitorias deleteMany
   */
  export type vitoriasDeleteManyArgs = {
    /**
     * Filter which vitorias to delete
     * 
    **/
    where?: vitoriasWhereInput
  }


  /**
   * vitorias: findUniqueOrThrow
   */
  export type vitoriasFindUniqueOrThrowArgs = vitoriasFindUniqueArgsBase
      

  /**
   * vitorias: findFirstOrThrow
   */
  export type vitoriasFindFirstOrThrowArgs = vitoriasFindFirstArgsBase
      

  /**
   * vitorias without action
   */
  export type vitoriasArgs = {
    /**
     * Select specific fields to fetch from the vitorias
     * 
    **/
    select?: vitoriasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: vitoriasInclude | null
  }



  /**
   * Model ranking
   */


  export type AggregateRanking = {
    _count: RankingCountAggregateOutputType | null
    _avg: RankingAvgAggregateOutputType | null
    _sum: RankingSumAggregateOutputType | null
    _min: RankingMinAggregateOutputType | null
    _max: RankingMaxAggregateOutputType | null
  }

  export type RankingAvgAggregateOutputType = {
    id: number | null
    ranking: number | null
    usuarioId: number | null
  }

  export type RankingSumAggregateOutputType = {
    id: number | null
    ranking: number | null
    usuarioId: number | null
  }

  export type RankingMinAggregateOutputType = {
    id: number | null
    ranking: number | null
    usuarioId: number | null
    nome: string | null
    foto: string | null
  }

  export type RankingMaxAggregateOutputType = {
    id: number | null
    ranking: number | null
    usuarioId: number | null
    nome: string | null
    foto: string | null
  }

  export type RankingCountAggregateOutputType = {
    id: number
    ranking: number
    usuarioId: number
    nome: number
    foto: number
    _all: number
  }


  export type RankingAvgAggregateInputType = {
    id?: true
    ranking?: true
    usuarioId?: true
  }

  export type RankingSumAggregateInputType = {
    id?: true
    ranking?: true
    usuarioId?: true
  }

  export type RankingMinAggregateInputType = {
    id?: true
    ranking?: true
    usuarioId?: true
    nome?: true
    foto?: true
  }

  export type RankingMaxAggregateInputType = {
    id?: true
    ranking?: true
    usuarioId?: true
    nome?: true
    foto?: true
  }

  export type RankingCountAggregateInputType = {
    id?: true
    ranking?: true
    usuarioId?: true
    nome?: true
    foto?: true
    _all?: true
  }

  export type RankingAggregateArgs = {
    /**
     * Filter which ranking to aggregate.
     * 
    **/
    where?: rankingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rankings to fetch.
     * 
    **/
    orderBy?: Enumerable<rankingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: rankingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rankings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rankings.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned rankings
    **/
    _count?: true | RankingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RankingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RankingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RankingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RankingMaxAggregateInputType
  }

  export type GetRankingAggregateType<T extends RankingAggregateArgs> = {
        [P in keyof T & keyof AggregateRanking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRanking[P]>
      : GetScalarType<T[P], AggregateRanking[P]>
  }




  export type RankingGroupByArgs = {
    where?: rankingWhereInput
    orderBy?: Enumerable<rankingOrderByWithAggregationInput>
    by: Array<RankingScalarFieldEnum>
    having?: rankingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RankingCountAggregateInputType | true
    _avg?: RankingAvgAggregateInputType
    _sum?: RankingSumAggregateInputType
    _min?: RankingMinAggregateInputType
    _max?: RankingMaxAggregateInputType
  }


  export type RankingGroupByOutputType = {
    id: number
    ranking: number
    usuarioId: number
    nome: string
    foto: string
    _count: RankingCountAggregateOutputType | null
    _avg: RankingAvgAggregateOutputType | null
    _sum: RankingSumAggregateOutputType | null
    _min: RankingMinAggregateOutputType | null
    _max: RankingMaxAggregateOutputType | null
  }

  type GetRankingGroupByPayload<T extends RankingGroupByArgs> = PrismaPromise<
    Array<
      PickArray<RankingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RankingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RankingGroupByOutputType[P]>
            : GetScalarType<T[P], RankingGroupByOutputType[P]>
        }
      >
    >


  export type rankingSelect = {
    id?: boolean
    ranking?: boolean
    usuarioId?: boolean
    nome?: boolean
    foto?: boolean
  }

  export type rankingGetPayload<
    S extends boolean | null | undefined | rankingArgs,
    U = keyof S
      > = S extends true
        ? ranking
    : S extends undefined
    ? never
    : S extends rankingArgs | rankingFindManyArgs
    ?'include' extends U
    ? ranking 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ranking ? ranking[P] : never
  } 
    : ranking
  : ranking


  type rankingCountArgs = Merge<
    Omit<rankingFindManyArgs, 'select' | 'include'> & {
      select?: RankingCountAggregateInputType | true
    }
  >

  export interface rankingDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Ranking that matches the filter.
     * @param {rankingFindUniqueArgs} args - Arguments to find a Ranking
     * @example
     * // Get one Ranking
     * const ranking = await prisma.ranking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends rankingFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, rankingFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ranking'> extends True ? CheckSelect<T, Prisma__rankingClient<ranking>, Prisma__rankingClient<rankingGetPayload<T>>> : CheckSelect<T, Prisma__rankingClient<ranking | null, null>, Prisma__rankingClient<rankingGetPayload<T> | null, null>>

    /**
     * Find the first Ranking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rankingFindFirstArgs} args - Arguments to find a Ranking
     * @example
     * // Get one Ranking
     * const ranking = await prisma.ranking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends rankingFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, rankingFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ranking'> extends True ? CheckSelect<T, Prisma__rankingClient<ranking>, Prisma__rankingClient<rankingGetPayload<T>>> : CheckSelect<T, Prisma__rankingClient<ranking | null, null>, Prisma__rankingClient<rankingGetPayload<T> | null, null>>

    /**
     * Find zero or more Rankings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rankingFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rankings
     * const rankings = await prisma.ranking.findMany()
     * 
     * // Get first 10 Rankings
     * const rankings = await prisma.ranking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rankingWithIdOnly = await prisma.ranking.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends rankingFindManyArgs>(
      args?: SelectSubset<T, rankingFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ranking>>, PrismaPromise<Array<rankingGetPayload<T>>>>

    /**
     * Create a Ranking.
     * @param {rankingCreateArgs} args - Arguments to create a Ranking.
     * @example
     * // Create one Ranking
     * const Ranking = await prisma.ranking.create({
     *   data: {
     *     // ... data to create a Ranking
     *   }
     * })
     * 
    **/
    create<T extends rankingCreateArgs>(
      args: SelectSubset<T, rankingCreateArgs>
    ): CheckSelect<T, Prisma__rankingClient<ranking>, Prisma__rankingClient<rankingGetPayload<T>>>

    /**
     * Create many Rankings.
     *     @param {rankingCreateManyArgs} args - Arguments to create many Rankings.
     *     @example
     *     // Create many Rankings
     *     const ranking = await prisma.ranking.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends rankingCreateManyArgs>(
      args?: SelectSubset<T, rankingCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Ranking.
     * @param {rankingDeleteArgs} args - Arguments to delete one Ranking.
     * @example
     * // Delete one Ranking
     * const Ranking = await prisma.ranking.delete({
     *   where: {
     *     // ... filter to delete one Ranking
     *   }
     * })
     * 
    **/
    delete<T extends rankingDeleteArgs>(
      args: SelectSubset<T, rankingDeleteArgs>
    ): CheckSelect<T, Prisma__rankingClient<ranking>, Prisma__rankingClient<rankingGetPayload<T>>>

    /**
     * Update one Ranking.
     * @param {rankingUpdateArgs} args - Arguments to update one Ranking.
     * @example
     * // Update one Ranking
     * const ranking = await prisma.ranking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends rankingUpdateArgs>(
      args: SelectSubset<T, rankingUpdateArgs>
    ): CheckSelect<T, Prisma__rankingClient<ranking>, Prisma__rankingClient<rankingGetPayload<T>>>

    /**
     * Delete zero or more Rankings.
     * @param {rankingDeleteManyArgs} args - Arguments to filter Rankings to delete.
     * @example
     * // Delete a few Rankings
     * const { count } = await prisma.ranking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends rankingDeleteManyArgs>(
      args?: SelectSubset<T, rankingDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rankings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rankingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rankings
     * const ranking = await prisma.ranking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends rankingUpdateManyArgs>(
      args: SelectSubset<T, rankingUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Ranking.
     * @param {rankingUpsertArgs} args - Arguments to update or create a Ranking.
     * @example
     * // Update or create a Ranking
     * const ranking = await prisma.ranking.upsert({
     *   create: {
     *     // ... data to create a Ranking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ranking we want to update
     *   }
     * })
    **/
    upsert<T extends rankingUpsertArgs>(
      args: SelectSubset<T, rankingUpsertArgs>
    ): CheckSelect<T, Prisma__rankingClient<ranking>, Prisma__rankingClient<rankingGetPayload<T>>>

    /**
     * Find one Ranking that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {rankingFindUniqueOrThrowArgs} args - Arguments to find a Ranking
     * @example
     * // Get one Ranking
     * const ranking = await prisma.ranking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends rankingFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, rankingFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__rankingClient<ranking>, Prisma__rankingClient<rankingGetPayload<T>>>

    /**
     * Find the first Ranking that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rankingFindFirstOrThrowArgs} args - Arguments to find a Ranking
     * @example
     * // Get one Ranking
     * const ranking = await prisma.ranking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends rankingFindFirstOrThrowArgs>(
      args?: SelectSubset<T, rankingFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__rankingClient<ranking>, Prisma__rankingClient<rankingGetPayload<T>>>

    /**
     * Count the number of Rankings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rankingCountArgs} args - Arguments to filter Rankings to count.
     * @example
     * // Count the number of Rankings
     * const count = await prisma.ranking.count({
     *   where: {
     *     // ... the filter for the Rankings we want to count
     *   }
     * })
    **/
    count<T extends rankingCountArgs>(
      args?: Subset<T, rankingCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RankingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ranking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RankingAggregateArgs>(args: Subset<T, RankingAggregateArgs>): PrismaPromise<GetRankingAggregateType<T>>

    /**
     * Group by Ranking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RankingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RankingGroupByArgs['orderBy'] }
        : { orderBy?: RankingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RankingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRankingGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ranking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__rankingClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ranking base type for findUnique actions
   */
  export type rankingFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ranking
     * 
    **/
    select?: rankingSelect | null
    /**
     * Filter, which ranking to fetch.
     * 
    **/
    where: rankingWhereUniqueInput
  }

  /**
   * ranking: findUnique
   */
  export interface rankingFindUniqueArgs extends rankingFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ranking base type for findFirst actions
   */
  export type rankingFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ranking
     * 
    **/
    select?: rankingSelect | null
    /**
     * Filter, which ranking to fetch.
     * 
    **/
    where?: rankingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rankings to fetch.
     * 
    **/
    orderBy?: Enumerable<rankingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rankings.
     * 
    **/
    cursor?: rankingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rankings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rankings.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rankings.
     * 
    **/
    distinct?: Enumerable<RankingScalarFieldEnum>
  }

  /**
   * ranking: findFirst
   */
  export interface rankingFindFirstArgs extends rankingFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ranking findMany
   */
  export type rankingFindManyArgs = {
    /**
     * Select specific fields to fetch from the ranking
     * 
    **/
    select?: rankingSelect | null
    /**
     * Filter, which rankings to fetch.
     * 
    **/
    where?: rankingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rankings to fetch.
     * 
    **/
    orderBy?: Enumerable<rankingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing rankings.
     * 
    **/
    cursor?: rankingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rankings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rankings.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RankingScalarFieldEnum>
  }


  /**
   * ranking create
   */
  export type rankingCreateArgs = {
    /**
     * Select specific fields to fetch from the ranking
     * 
    **/
    select?: rankingSelect | null
    /**
     * The data needed to create a ranking.
     * 
    **/
    data: XOR<rankingCreateInput, rankingUncheckedCreateInput>
  }


  /**
   * ranking createMany
   */
  export type rankingCreateManyArgs = {
    /**
     * The data used to create many rankings.
     * 
    **/
    data: Enumerable<rankingCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ranking update
   */
  export type rankingUpdateArgs = {
    /**
     * Select specific fields to fetch from the ranking
     * 
    **/
    select?: rankingSelect | null
    /**
     * The data needed to update a ranking.
     * 
    **/
    data: XOR<rankingUpdateInput, rankingUncheckedUpdateInput>
    /**
     * Choose, which ranking to update.
     * 
    **/
    where: rankingWhereUniqueInput
  }


  /**
   * ranking updateMany
   */
  export type rankingUpdateManyArgs = {
    /**
     * The data used to update rankings.
     * 
    **/
    data: XOR<rankingUpdateManyMutationInput, rankingUncheckedUpdateManyInput>
    /**
     * Filter which rankings to update
     * 
    **/
    where?: rankingWhereInput
  }


  /**
   * ranking upsert
   */
  export type rankingUpsertArgs = {
    /**
     * Select specific fields to fetch from the ranking
     * 
    **/
    select?: rankingSelect | null
    /**
     * The filter to search for the ranking to update in case it exists.
     * 
    **/
    where: rankingWhereUniqueInput
    /**
     * In case the ranking found by the `where` argument doesn't exist, create a new ranking with this data.
     * 
    **/
    create: XOR<rankingCreateInput, rankingUncheckedCreateInput>
    /**
     * In case the ranking was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<rankingUpdateInput, rankingUncheckedUpdateInput>
  }


  /**
   * ranking delete
   */
  export type rankingDeleteArgs = {
    /**
     * Select specific fields to fetch from the ranking
     * 
    **/
    select?: rankingSelect | null
    /**
     * Filter which ranking to delete.
     * 
    **/
    where: rankingWhereUniqueInput
  }


  /**
   * ranking deleteMany
   */
  export type rankingDeleteManyArgs = {
    /**
     * Filter which rankings to delete
     * 
    **/
    where?: rankingWhereInput
  }


  /**
   * ranking: findUniqueOrThrow
   */
  export type rankingFindUniqueOrThrowArgs = rankingFindUniqueArgsBase
      

  /**
   * ranking: findFirstOrThrow
   */
  export type rankingFindFirstOrThrowArgs = rankingFindFirstArgsBase
      

  /**
   * ranking without action
   */
  export type rankingArgs = {
    /**
     * Select specific fields to fetch from the ranking
     * 
    **/
    select?: rankingSelect | null
  }



  /**
   * Model ouro
   */


  export type AggregateOuro = {
    _count: OuroCountAggregateOutputType | null
    _avg: OuroAvgAggregateOutputType | null
    _sum: OuroSumAggregateOutputType | null
    _min: OuroMinAggregateOutputType | null
    _max: OuroMaxAggregateOutputType | null
  }

  export type OuroAvgAggregateOutputType = {
    id: number | null
    ouro: number | null
    usuarioId: number | null
  }

  export type OuroSumAggregateOutputType = {
    id: number | null
    ouro: number | null
    usuarioId: number | null
  }

  export type OuroMinAggregateOutputType = {
    id: number | null
    ouro: number | null
    usuarioId: number | null
  }

  export type OuroMaxAggregateOutputType = {
    id: number | null
    ouro: number | null
    usuarioId: number | null
  }

  export type OuroCountAggregateOutputType = {
    id: number
    ouro: number
    usuarioId: number
    _all: number
  }


  export type OuroAvgAggregateInputType = {
    id?: true
    ouro?: true
    usuarioId?: true
  }

  export type OuroSumAggregateInputType = {
    id?: true
    ouro?: true
    usuarioId?: true
  }

  export type OuroMinAggregateInputType = {
    id?: true
    ouro?: true
    usuarioId?: true
  }

  export type OuroMaxAggregateInputType = {
    id?: true
    ouro?: true
    usuarioId?: true
  }

  export type OuroCountAggregateInputType = {
    id?: true
    ouro?: true
    usuarioId?: true
    _all?: true
  }

  export type OuroAggregateArgs = {
    /**
     * Filter which ouro to aggregate.
     * 
    **/
    where?: ouroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ouros to fetch.
     * 
    **/
    orderBy?: Enumerable<ouroOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ouroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ouros from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ouros.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ouros
    **/
    _count?: true | OuroCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OuroAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OuroSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OuroMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OuroMaxAggregateInputType
  }

  export type GetOuroAggregateType<T extends OuroAggregateArgs> = {
        [P in keyof T & keyof AggregateOuro]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOuro[P]>
      : GetScalarType<T[P], AggregateOuro[P]>
  }




  export type OuroGroupByArgs = {
    where?: ouroWhereInput
    orderBy?: Enumerable<ouroOrderByWithAggregationInput>
    by: Array<OuroScalarFieldEnum>
    having?: ouroScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OuroCountAggregateInputType | true
    _avg?: OuroAvgAggregateInputType
    _sum?: OuroSumAggregateInputType
    _min?: OuroMinAggregateInputType
    _max?: OuroMaxAggregateInputType
  }


  export type OuroGroupByOutputType = {
    id: number
    ouro: number
    usuarioId: number
    _count: OuroCountAggregateOutputType | null
    _avg: OuroAvgAggregateOutputType | null
    _sum: OuroSumAggregateOutputType | null
    _min: OuroMinAggregateOutputType | null
    _max: OuroMaxAggregateOutputType | null
  }

  type GetOuroGroupByPayload<T extends OuroGroupByArgs> = PrismaPromise<
    Array<
      PickArray<OuroGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OuroGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OuroGroupByOutputType[P]>
            : GetScalarType<T[P], OuroGroupByOutputType[P]>
        }
      >
    >


  export type ouroSelect = {
    id?: boolean
    ouro?: boolean
    usuarioId?: boolean
    usuario?: boolean | usuarioArgs
  }

  export type ouroInclude = {
    usuario?: boolean | usuarioArgs
  }

  export type ouroGetPayload<
    S extends boolean | null | undefined | ouroArgs,
    U = keyof S
      > = S extends true
        ? ouro
    : S extends undefined
    ? never
    : S extends ouroArgs | ouroFindManyArgs
    ?'include' extends U
    ? ouro  & {
    [P in TrueKeys<S['include']>]:
        P extends 'usuario' ? usuarioGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'usuario' ? usuarioGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof ouro ? ouro[P] : never
  } 
    : ouro
  : ouro


  type ouroCountArgs = Merge<
    Omit<ouroFindManyArgs, 'select' | 'include'> & {
      select?: OuroCountAggregateInputType | true
    }
  >

  export interface ouroDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Ouro that matches the filter.
     * @param {ouroFindUniqueArgs} args - Arguments to find a Ouro
     * @example
     * // Get one Ouro
     * const ouro = await prisma.ouro.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ouroFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ouroFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ouro'> extends True ? CheckSelect<T, Prisma__ouroClient<ouro>, Prisma__ouroClient<ouroGetPayload<T>>> : CheckSelect<T, Prisma__ouroClient<ouro | null, null>, Prisma__ouroClient<ouroGetPayload<T> | null, null>>

    /**
     * Find the first Ouro that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ouroFindFirstArgs} args - Arguments to find a Ouro
     * @example
     * // Get one Ouro
     * const ouro = await prisma.ouro.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ouroFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ouroFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ouro'> extends True ? CheckSelect<T, Prisma__ouroClient<ouro>, Prisma__ouroClient<ouroGetPayload<T>>> : CheckSelect<T, Prisma__ouroClient<ouro | null, null>, Prisma__ouroClient<ouroGetPayload<T> | null, null>>

    /**
     * Find zero or more Ouros that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ouroFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ouros
     * const ouros = await prisma.ouro.findMany()
     * 
     * // Get first 10 Ouros
     * const ouros = await prisma.ouro.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ouroWithIdOnly = await prisma.ouro.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ouroFindManyArgs>(
      args?: SelectSubset<T, ouroFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ouro>>, PrismaPromise<Array<ouroGetPayload<T>>>>

    /**
     * Create a Ouro.
     * @param {ouroCreateArgs} args - Arguments to create a Ouro.
     * @example
     * // Create one Ouro
     * const Ouro = await prisma.ouro.create({
     *   data: {
     *     // ... data to create a Ouro
     *   }
     * })
     * 
    **/
    create<T extends ouroCreateArgs>(
      args: SelectSubset<T, ouroCreateArgs>
    ): CheckSelect<T, Prisma__ouroClient<ouro>, Prisma__ouroClient<ouroGetPayload<T>>>

    /**
     * Create many Ouros.
     *     @param {ouroCreateManyArgs} args - Arguments to create many Ouros.
     *     @example
     *     // Create many Ouros
     *     const ouro = await prisma.ouro.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ouroCreateManyArgs>(
      args?: SelectSubset<T, ouroCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Ouro.
     * @param {ouroDeleteArgs} args - Arguments to delete one Ouro.
     * @example
     * // Delete one Ouro
     * const Ouro = await prisma.ouro.delete({
     *   where: {
     *     // ... filter to delete one Ouro
     *   }
     * })
     * 
    **/
    delete<T extends ouroDeleteArgs>(
      args: SelectSubset<T, ouroDeleteArgs>
    ): CheckSelect<T, Prisma__ouroClient<ouro>, Prisma__ouroClient<ouroGetPayload<T>>>

    /**
     * Update one Ouro.
     * @param {ouroUpdateArgs} args - Arguments to update one Ouro.
     * @example
     * // Update one Ouro
     * const ouro = await prisma.ouro.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ouroUpdateArgs>(
      args: SelectSubset<T, ouroUpdateArgs>
    ): CheckSelect<T, Prisma__ouroClient<ouro>, Prisma__ouroClient<ouroGetPayload<T>>>

    /**
     * Delete zero or more Ouros.
     * @param {ouroDeleteManyArgs} args - Arguments to filter Ouros to delete.
     * @example
     * // Delete a few Ouros
     * const { count } = await prisma.ouro.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ouroDeleteManyArgs>(
      args?: SelectSubset<T, ouroDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ouros.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ouroUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ouros
     * const ouro = await prisma.ouro.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ouroUpdateManyArgs>(
      args: SelectSubset<T, ouroUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Ouro.
     * @param {ouroUpsertArgs} args - Arguments to update or create a Ouro.
     * @example
     * // Update or create a Ouro
     * const ouro = await prisma.ouro.upsert({
     *   create: {
     *     // ... data to create a Ouro
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ouro we want to update
     *   }
     * })
    **/
    upsert<T extends ouroUpsertArgs>(
      args: SelectSubset<T, ouroUpsertArgs>
    ): CheckSelect<T, Prisma__ouroClient<ouro>, Prisma__ouroClient<ouroGetPayload<T>>>

    /**
     * Find one Ouro that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {ouroFindUniqueOrThrowArgs} args - Arguments to find a Ouro
     * @example
     * // Get one Ouro
     * const ouro = await prisma.ouro.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ouroFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ouroFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__ouroClient<ouro>, Prisma__ouroClient<ouroGetPayload<T>>>

    /**
     * Find the first Ouro that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ouroFindFirstOrThrowArgs} args - Arguments to find a Ouro
     * @example
     * // Get one Ouro
     * const ouro = await prisma.ouro.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ouroFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ouroFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__ouroClient<ouro>, Prisma__ouroClient<ouroGetPayload<T>>>

    /**
     * Count the number of Ouros.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ouroCountArgs} args - Arguments to filter Ouros to count.
     * @example
     * // Count the number of Ouros
     * const count = await prisma.ouro.count({
     *   where: {
     *     // ... the filter for the Ouros we want to count
     *   }
     * })
    **/
    count<T extends ouroCountArgs>(
      args?: Subset<T, ouroCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OuroCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ouro.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OuroAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OuroAggregateArgs>(args: Subset<T, OuroAggregateArgs>): PrismaPromise<GetOuroAggregateType<T>>

    /**
     * Group by Ouro.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OuroGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OuroGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OuroGroupByArgs['orderBy'] }
        : { orderBy?: OuroGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OuroGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOuroGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ouro.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ouroClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    usuario<T extends usuarioArgs = {}>(args?: Subset<T, usuarioArgs>): CheckSelect<T, Prisma__usuarioClient<usuario | Null>, Prisma__usuarioClient<usuarioGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ouro base type for findUnique actions
   */
  export type ouroFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ouro
     * 
    **/
    select?: ouroSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ouroInclude | null
    /**
     * Filter, which ouro to fetch.
     * 
    **/
    where: ouroWhereUniqueInput
  }

  /**
   * ouro: findUnique
   */
  export interface ouroFindUniqueArgs extends ouroFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ouro base type for findFirst actions
   */
  export type ouroFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ouro
     * 
    **/
    select?: ouroSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ouroInclude | null
    /**
     * Filter, which ouro to fetch.
     * 
    **/
    where?: ouroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ouros to fetch.
     * 
    **/
    orderBy?: Enumerable<ouroOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ouros.
     * 
    **/
    cursor?: ouroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ouros from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ouros.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ouros.
     * 
    **/
    distinct?: Enumerable<OuroScalarFieldEnum>
  }

  /**
   * ouro: findFirst
   */
  export interface ouroFindFirstArgs extends ouroFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ouro findMany
   */
  export type ouroFindManyArgs = {
    /**
     * Select specific fields to fetch from the ouro
     * 
    **/
    select?: ouroSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ouroInclude | null
    /**
     * Filter, which ouros to fetch.
     * 
    **/
    where?: ouroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ouros to fetch.
     * 
    **/
    orderBy?: Enumerable<ouroOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ouros.
     * 
    **/
    cursor?: ouroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ouros from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ouros.
     * 
    **/
    skip?: number
    distinct?: Enumerable<OuroScalarFieldEnum>
  }


  /**
   * ouro create
   */
  export type ouroCreateArgs = {
    /**
     * Select specific fields to fetch from the ouro
     * 
    **/
    select?: ouroSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ouroInclude | null
    /**
     * The data needed to create a ouro.
     * 
    **/
    data: XOR<ouroCreateInput, ouroUncheckedCreateInput>
  }


  /**
   * ouro createMany
   */
  export type ouroCreateManyArgs = {
    /**
     * The data used to create many ouros.
     * 
    **/
    data: Enumerable<ouroCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ouro update
   */
  export type ouroUpdateArgs = {
    /**
     * Select specific fields to fetch from the ouro
     * 
    **/
    select?: ouroSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ouroInclude | null
    /**
     * The data needed to update a ouro.
     * 
    **/
    data: XOR<ouroUpdateInput, ouroUncheckedUpdateInput>
    /**
     * Choose, which ouro to update.
     * 
    **/
    where: ouroWhereUniqueInput
  }


  /**
   * ouro updateMany
   */
  export type ouroUpdateManyArgs = {
    /**
     * The data used to update ouros.
     * 
    **/
    data: XOR<ouroUpdateManyMutationInput, ouroUncheckedUpdateManyInput>
    /**
     * Filter which ouros to update
     * 
    **/
    where?: ouroWhereInput
  }


  /**
   * ouro upsert
   */
  export type ouroUpsertArgs = {
    /**
     * Select specific fields to fetch from the ouro
     * 
    **/
    select?: ouroSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ouroInclude | null
    /**
     * The filter to search for the ouro to update in case it exists.
     * 
    **/
    where: ouroWhereUniqueInput
    /**
     * In case the ouro found by the `where` argument doesn't exist, create a new ouro with this data.
     * 
    **/
    create: XOR<ouroCreateInput, ouroUncheckedCreateInput>
    /**
     * In case the ouro was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ouroUpdateInput, ouroUncheckedUpdateInput>
  }


  /**
   * ouro delete
   */
  export type ouroDeleteArgs = {
    /**
     * Select specific fields to fetch from the ouro
     * 
    **/
    select?: ouroSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ouroInclude | null
    /**
     * Filter which ouro to delete.
     * 
    **/
    where: ouroWhereUniqueInput
  }


  /**
   * ouro deleteMany
   */
  export type ouroDeleteManyArgs = {
    /**
     * Filter which ouros to delete
     * 
    **/
    where?: ouroWhereInput
  }


  /**
   * ouro: findUniqueOrThrow
   */
  export type ouroFindUniqueOrThrowArgs = ouroFindUniqueArgsBase
      

  /**
   * ouro: findFirstOrThrow
   */
  export type ouroFindFirstOrThrowArgs = ouroFindFirstArgsBase
      

  /**
   * ouro without action
   */
  export type ouroArgs = {
    /**
     * Select specific fields to fetch from the ouro
     * 
    **/
    select?: ouroSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ouroInclude | null
  }



  /**
   * Model ouroCard
   */


  export type AggregateOuroCard = {
    _count: OuroCardCountAggregateOutputType | null
    _avg: OuroCardAvgAggregateOutputType | null
    _sum: OuroCardSumAggregateOutputType | null
    _min: OuroCardMinAggregateOutputType | null
    _max: OuroCardMaxAggregateOutputType | null
  }

  export type OuroCardAvgAggregateOutputType = {
    id: number | null
    ouro: number | null
    cardId: number | null
  }

  export type OuroCardSumAggregateOutputType = {
    id: number | null
    ouro: number | null
    cardId: number | null
  }

  export type OuroCardMinAggregateOutputType = {
    id: number | null
    ouro: number | null
    cardId: number | null
  }

  export type OuroCardMaxAggregateOutputType = {
    id: number | null
    ouro: number | null
    cardId: number | null
  }

  export type OuroCardCountAggregateOutputType = {
    id: number
    ouro: number
    cardId: number
    _all: number
  }


  export type OuroCardAvgAggregateInputType = {
    id?: true
    ouro?: true
    cardId?: true
  }

  export type OuroCardSumAggregateInputType = {
    id?: true
    ouro?: true
    cardId?: true
  }

  export type OuroCardMinAggregateInputType = {
    id?: true
    ouro?: true
    cardId?: true
  }

  export type OuroCardMaxAggregateInputType = {
    id?: true
    ouro?: true
    cardId?: true
  }

  export type OuroCardCountAggregateInputType = {
    id?: true
    ouro?: true
    cardId?: true
    _all?: true
  }

  export type OuroCardAggregateArgs = {
    /**
     * Filter which ouroCard to aggregate.
     * 
    **/
    where?: ouroCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ouroCards to fetch.
     * 
    **/
    orderBy?: Enumerable<ouroCardOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ouroCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ouroCards from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ouroCards.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ouroCards
    **/
    _count?: true | OuroCardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OuroCardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OuroCardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OuroCardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OuroCardMaxAggregateInputType
  }

  export type GetOuroCardAggregateType<T extends OuroCardAggregateArgs> = {
        [P in keyof T & keyof AggregateOuroCard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOuroCard[P]>
      : GetScalarType<T[P], AggregateOuroCard[P]>
  }




  export type OuroCardGroupByArgs = {
    where?: ouroCardWhereInput
    orderBy?: Enumerable<ouroCardOrderByWithAggregationInput>
    by: Array<OuroCardScalarFieldEnum>
    having?: ouroCardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OuroCardCountAggregateInputType | true
    _avg?: OuroCardAvgAggregateInputType
    _sum?: OuroCardSumAggregateInputType
    _min?: OuroCardMinAggregateInputType
    _max?: OuroCardMaxAggregateInputType
  }


  export type OuroCardGroupByOutputType = {
    id: number
    ouro: number
    cardId: number
    _count: OuroCardCountAggregateOutputType | null
    _avg: OuroCardAvgAggregateOutputType | null
    _sum: OuroCardSumAggregateOutputType | null
    _min: OuroCardMinAggregateOutputType | null
    _max: OuroCardMaxAggregateOutputType | null
  }

  type GetOuroCardGroupByPayload<T extends OuroCardGroupByArgs> = PrismaPromise<
    Array<
      PickArray<OuroCardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OuroCardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OuroCardGroupByOutputType[P]>
            : GetScalarType<T[P], OuroCardGroupByOutputType[P]>
        }
      >
    >


  export type ouroCardSelect = {
    id?: boolean
    ouro?: boolean
    cardId?: boolean
    card?: boolean | cardArgs
  }

  export type ouroCardInclude = {
    card?: boolean | cardArgs
  }

  export type ouroCardGetPayload<
    S extends boolean | null | undefined | ouroCardArgs,
    U = keyof S
      > = S extends true
        ? ouroCard
    : S extends undefined
    ? never
    : S extends ouroCardArgs | ouroCardFindManyArgs
    ?'include' extends U
    ? ouroCard  & {
    [P in TrueKeys<S['include']>]:
        P extends 'card' ? cardGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'card' ? cardGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof ouroCard ? ouroCard[P] : never
  } 
    : ouroCard
  : ouroCard


  type ouroCardCountArgs = Merge<
    Omit<ouroCardFindManyArgs, 'select' | 'include'> & {
      select?: OuroCardCountAggregateInputType | true
    }
  >

  export interface ouroCardDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one OuroCard that matches the filter.
     * @param {ouroCardFindUniqueArgs} args - Arguments to find a OuroCard
     * @example
     * // Get one OuroCard
     * const ouroCard = await prisma.ouroCard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ouroCardFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ouroCardFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ouroCard'> extends True ? CheckSelect<T, Prisma__ouroCardClient<ouroCard>, Prisma__ouroCardClient<ouroCardGetPayload<T>>> : CheckSelect<T, Prisma__ouroCardClient<ouroCard | null, null>, Prisma__ouroCardClient<ouroCardGetPayload<T> | null, null>>

    /**
     * Find the first OuroCard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ouroCardFindFirstArgs} args - Arguments to find a OuroCard
     * @example
     * // Get one OuroCard
     * const ouroCard = await prisma.ouroCard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ouroCardFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ouroCardFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ouroCard'> extends True ? CheckSelect<T, Prisma__ouroCardClient<ouroCard>, Prisma__ouroCardClient<ouroCardGetPayload<T>>> : CheckSelect<T, Prisma__ouroCardClient<ouroCard | null, null>, Prisma__ouroCardClient<ouroCardGetPayload<T> | null, null>>

    /**
     * Find zero or more OuroCards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ouroCardFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OuroCards
     * const ouroCards = await prisma.ouroCard.findMany()
     * 
     * // Get first 10 OuroCards
     * const ouroCards = await prisma.ouroCard.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ouroCardWithIdOnly = await prisma.ouroCard.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ouroCardFindManyArgs>(
      args?: SelectSubset<T, ouroCardFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ouroCard>>, PrismaPromise<Array<ouroCardGetPayload<T>>>>

    /**
     * Create a OuroCard.
     * @param {ouroCardCreateArgs} args - Arguments to create a OuroCard.
     * @example
     * // Create one OuroCard
     * const OuroCard = await prisma.ouroCard.create({
     *   data: {
     *     // ... data to create a OuroCard
     *   }
     * })
     * 
    **/
    create<T extends ouroCardCreateArgs>(
      args: SelectSubset<T, ouroCardCreateArgs>
    ): CheckSelect<T, Prisma__ouroCardClient<ouroCard>, Prisma__ouroCardClient<ouroCardGetPayload<T>>>

    /**
     * Create many OuroCards.
     *     @param {ouroCardCreateManyArgs} args - Arguments to create many OuroCards.
     *     @example
     *     // Create many OuroCards
     *     const ouroCard = await prisma.ouroCard.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ouroCardCreateManyArgs>(
      args?: SelectSubset<T, ouroCardCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a OuroCard.
     * @param {ouroCardDeleteArgs} args - Arguments to delete one OuroCard.
     * @example
     * // Delete one OuroCard
     * const OuroCard = await prisma.ouroCard.delete({
     *   where: {
     *     // ... filter to delete one OuroCard
     *   }
     * })
     * 
    **/
    delete<T extends ouroCardDeleteArgs>(
      args: SelectSubset<T, ouroCardDeleteArgs>
    ): CheckSelect<T, Prisma__ouroCardClient<ouroCard>, Prisma__ouroCardClient<ouroCardGetPayload<T>>>

    /**
     * Update one OuroCard.
     * @param {ouroCardUpdateArgs} args - Arguments to update one OuroCard.
     * @example
     * // Update one OuroCard
     * const ouroCard = await prisma.ouroCard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ouroCardUpdateArgs>(
      args: SelectSubset<T, ouroCardUpdateArgs>
    ): CheckSelect<T, Prisma__ouroCardClient<ouroCard>, Prisma__ouroCardClient<ouroCardGetPayload<T>>>

    /**
     * Delete zero or more OuroCards.
     * @param {ouroCardDeleteManyArgs} args - Arguments to filter OuroCards to delete.
     * @example
     * // Delete a few OuroCards
     * const { count } = await prisma.ouroCard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ouroCardDeleteManyArgs>(
      args?: SelectSubset<T, ouroCardDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more OuroCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ouroCardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OuroCards
     * const ouroCard = await prisma.ouroCard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ouroCardUpdateManyArgs>(
      args: SelectSubset<T, ouroCardUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one OuroCard.
     * @param {ouroCardUpsertArgs} args - Arguments to update or create a OuroCard.
     * @example
     * // Update or create a OuroCard
     * const ouroCard = await prisma.ouroCard.upsert({
     *   create: {
     *     // ... data to create a OuroCard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OuroCard we want to update
     *   }
     * })
    **/
    upsert<T extends ouroCardUpsertArgs>(
      args: SelectSubset<T, ouroCardUpsertArgs>
    ): CheckSelect<T, Prisma__ouroCardClient<ouroCard>, Prisma__ouroCardClient<ouroCardGetPayload<T>>>

    /**
     * Find one OuroCard that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {ouroCardFindUniqueOrThrowArgs} args - Arguments to find a OuroCard
     * @example
     * // Get one OuroCard
     * const ouroCard = await prisma.ouroCard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ouroCardFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ouroCardFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__ouroCardClient<ouroCard>, Prisma__ouroCardClient<ouroCardGetPayload<T>>>

    /**
     * Find the first OuroCard that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ouroCardFindFirstOrThrowArgs} args - Arguments to find a OuroCard
     * @example
     * // Get one OuroCard
     * const ouroCard = await prisma.ouroCard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ouroCardFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ouroCardFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__ouroCardClient<ouroCard>, Prisma__ouroCardClient<ouroCardGetPayload<T>>>

    /**
     * Count the number of OuroCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ouroCardCountArgs} args - Arguments to filter OuroCards to count.
     * @example
     * // Count the number of OuroCards
     * const count = await prisma.ouroCard.count({
     *   where: {
     *     // ... the filter for the OuroCards we want to count
     *   }
     * })
    **/
    count<T extends ouroCardCountArgs>(
      args?: Subset<T, ouroCardCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OuroCardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OuroCard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OuroCardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OuroCardAggregateArgs>(args: Subset<T, OuroCardAggregateArgs>): PrismaPromise<GetOuroCardAggregateType<T>>

    /**
     * Group by OuroCard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OuroCardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OuroCardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OuroCardGroupByArgs['orderBy'] }
        : { orderBy?: OuroCardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OuroCardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOuroCardGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ouroCard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ouroCardClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    card<T extends cardArgs = {}>(args?: Subset<T, cardArgs>): CheckSelect<T, Prisma__cardClient<card | Null>, Prisma__cardClient<cardGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ouroCard base type for findUnique actions
   */
  export type ouroCardFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ouroCard
     * 
    **/
    select?: ouroCardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ouroCardInclude | null
    /**
     * Filter, which ouroCard to fetch.
     * 
    **/
    where: ouroCardWhereUniqueInput
  }

  /**
   * ouroCard: findUnique
   */
  export interface ouroCardFindUniqueArgs extends ouroCardFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ouroCard base type for findFirst actions
   */
  export type ouroCardFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ouroCard
     * 
    **/
    select?: ouroCardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ouroCardInclude | null
    /**
     * Filter, which ouroCard to fetch.
     * 
    **/
    where?: ouroCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ouroCards to fetch.
     * 
    **/
    orderBy?: Enumerable<ouroCardOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ouroCards.
     * 
    **/
    cursor?: ouroCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ouroCards from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ouroCards.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ouroCards.
     * 
    **/
    distinct?: Enumerable<OuroCardScalarFieldEnum>
  }

  /**
   * ouroCard: findFirst
   */
  export interface ouroCardFindFirstArgs extends ouroCardFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ouroCard findMany
   */
  export type ouroCardFindManyArgs = {
    /**
     * Select specific fields to fetch from the ouroCard
     * 
    **/
    select?: ouroCardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ouroCardInclude | null
    /**
     * Filter, which ouroCards to fetch.
     * 
    **/
    where?: ouroCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ouroCards to fetch.
     * 
    **/
    orderBy?: Enumerable<ouroCardOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ouroCards.
     * 
    **/
    cursor?: ouroCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ouroCards from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ouroCards.
     * 
    **/
    skip?: number
    distinct?: Enumerable<OuroCardScalarFieldEnum>
  }


  /**
   * ouroCard create
   */
  export type ouroCardCreateArgs = {
    /**
     * Select specific fields to fetch from the ouroCard
     * 
    **/
    select?: ouroCardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ouroCardInclude | null
    /**
     * The data needed to create a ouroCard.
     * 
    **/
    data: XOR<ouroCardCreateInput, ouroCardUncheckedCreateInput>
  }


  /**
   * ouroCard createMany
   */
  export type ouroCardCreateManyArgs = {
    /**
     * The data used to create many ouroCards.
     * 
    **/
    data: Enumerable<ouroCardCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ouroCard update
   */
  export type ouroCardUpdateArgs = {
    /**
     * Select specific fields to fetch from the ouroCard
     * 
    **/
    select?: ouroCardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ouroCardInclude | null
    /**
     * The data needed to update a ouroCard.
     * 
    **/
    data: XOR<ouroCardUpdateInput, ouroCardUncheckedUpdateInput>
    /**
     * Choose, which ouroCard to update.
     * 
    **/
    where: ouroCardWhereUniqueInput
  }


  /**
   * ouroCard updateMany
   */
  export type ouroCardUpdateManyArgs = {
    /**
     * The data used to update ouroCards.
     * 
    **/
    data: XOR<ouroCardUpdateManyMutationInput, ouroCardUncheckedUpdateManyInput>
    /**
     * Filter which ouroCards to update
     * 
    **/
    where?: ouroCardWhereInput
  }


  /**
   * ouroCard upsert
   */
  export type ouroCardUpsertArgs = {
    /**
     * Select specific fields to fetch from the ouroCard
     * 
    **/
    select?: ouroCardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ouroCardInclude | null
    /**
     * The filter to search for the ouroCard to update in case it exists.
     * 
    **/
    where: ouroCardWhereUniqueInput
    /**
     * In case the ouroCard found by the `where` argument doesn't exist, create a new ouroCard with this data.
     * 
    **/
    create: XOR<ouroCardCreateInput, ouroCardUncheckedCreateInput>
    /**
     * In case the ouroCard was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ouroCardUpdateInput, ouroCardUncheckedUpdateInput>
  }


  /**
   * ouroCard delete
   */
  export type ouroCardDeleteArgs = {
    /**
     * Select specific fields to fetch from the ouroCard
     * 
    **/
    select?: ouroCardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ouroCardInclude | null
    /**
     * Filter which ouroCard to delete.
     * 
    **/
    where: ouroCardWhereUniqueInput
  }


  /**
   * ouroCard deleteMany
   */
  export type ouroCardDeleteManyArgs = {
    /**
     * Filter which ouroCards to delete
     * 
    **/
    where?: ouroCardWhereInput
  }


  /**
   * ouroCard: findUniqueOrThrow
   */
  export type ouroCardFindUniqueOrThrowArgs = ouroCardFindUniqueArgsBase
      

  /**
   * ouroCard: findFirstOrThrow
   */
  export type ouroCardFindFirstOrThrowArgs = ouroCardFindFirstArgsBase
      

  /**
   * ouroCard without action
   */
  export type ouroCardArgs = {
    /**
     * Select specific fields to fetch from the ouroCard
     * 
    **/
    select?: ouroCardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ouroCardInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const CardScalarFieldEnum: {
    id: 'id',
    foto: 'foto',
    poder: 'poder',
    vida: 'vida',
    nome: 'nome'
  };

  export type CardScalarFieldEnum = (typeof CardScalarFieldEnum)[keyof typeof CardScalarFieldEnum]


  export const DeckScalarFieldEnum: {
    id: 'id',
    idUser: 'idUser',
    vida: 'vida',
    maxVida: 'maxVida',
    nome: 'nome',
    foto: 'foto',
    idCard: 'idCard',
    poder: 'poder'
  };

  export type DeckScalarFieldEnum = (typeof DeckScalarFieldEnum)[keyof typeof DeckScalarFieldEnum]


  export const InimigoScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    foto: 'foto',
    fase: 'fase',
    idUsuario: 'idUsuario',
    idInimigos: 'idInimigos',
    poder: 'poder',
    vida: 'vida'
  };

  export type InimigoScalarFieldEnum = (typeof InimigoScalarFieldEnum)[keyof typeof InimigoScalarFieldEnum]


  export const InimigosScalarFieldEnum: {
    id: 'id',
    poder: 'poder',
    nome: 'nome',
    foto: 'foto',
    vida: 'vida',
    fase: 'fase'
  };

  export type InimigosScalarFieldEnum = (typeof InimigosScalarFieldEnum)[keyof typeof InimigosScalarFieldEnum]


  export const OuroCardScalarFieldEnum: {
    id: 'id',
    ouro: 'ouro',
    cardId: 'cardId'
  };

  export type OuroCardScalarFieldEnum = (typeof OuroCardScalarFieldEnum)[keyof typeof OuroCardScalarFieldEnum]


  export const OuroScalarFieldEnum: {
    id: 'id',
    ouro: 'ouro',
    usuarioId: 'usuarioId'
  };

  export type OuroScalarFieldEnum = (typeof OuroScalarFieldEnum)[keyof typeof OuroScalarFieldEnum]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const RankingScalarFieldEnum: {
    id: 'id',
    ranking: 'ranking',
    usuarioId: 'usuarioId',
    nome: 'nome',
    foto: 'foto'
  };

  export type RankingScalarFieldEnum = (typeof RankingScalarFieldEnum)[keyof typeof RankingScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UsuarioScalarFieldEnum: {
    id: 'id',
    token: 'token',
    senha: 'senha',
    email: 'email',
    foto: 'foto',
    nome: 'nome',
    fase: 'fase'
  };

  export type UsuarioScalarFieldEnum = (typeof UsuarioScalarFieldEnum)[keyof typeof UsuarioScalarFieldEnum]


  export const VitoriasScalarFieldEnum: {
    id: 'id',
    vitorias: 'vitorias',
    usuarioId: 'usuarioId'
  };

  export type VitoriasScalarFieldEnum = (typeof VitoriasScalarFieldEnum)[keyof typeof VitoriasScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type deckWhereInput = {
    AND?: Enumerable<deckWhereInput>
    OR?: Enumerable<deckWhereInput>
    NOT?: Enumerable<deckWhereInput>
    id?: IntFilter | number
    idUser?: IntFilter | number
    vida?: IntFilter | number
    maxVida?: IntFilter | number
    nome?: StringFilter | string
    foto?: StringFilter | string
    idCard?: IntFilter | number
    poder?: IntFilter | number
    card?: XOR<CardRelationFilter, cardWhereInput>
    usuario?: XOR<UsuarioRelationFilter, usuarioWhereInput>
  }

  export type deckOrderByWithRelationInput = {
    id?: SortOrder
    idUser?: SortOrder
    vida?: SortOrder
    maxVida?: SortOrder
    nome?: SortOrder
    foto?: SortOrder
    idCard?: SortOrder
    poder?: SortOrder
    card?: cardOrderByWithRelationInput
    usuario?: usuarioOrderByWithRelationInput
  }

  export type deckWhereUniqueInput = {
    id?: number
  }

  export type deckOrderByWithAggregationInput = {
    id?: SortOrder
    idUser?: SortOrder
    vida?: SortOrder
    maxVida?: SortOrder
    nome?: SortOrder
    foto?: SortOrder
    idCard?: SortOrder
    poder?: SortOrder
    _count?: deckCountOrderByAggregateInput
    _avg?: deckAvgOrderByAggregateInput
    _max?: deckMaxOrderByAggregateInput
    _min?: deckMinOrderByAggregateInput
    _sum?: deckSumOrderByAggregateInput
  }

  export type deckScalarWhereWithAggregatesInput = {
    AND?: Enumerable<deckScalarWhereWithAggregatesInput>
    OR?: Enumerable<deckScalarWhereWithAggregatesInput>
    NOT?: Enumerable<deckScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    idUser?: IntWithAggregatesFilter | number
    vida?: IntWithAggregatesFilter | number
    maxVida?: IntWithAggregatesFilter | number
    nome?: StringWithAggregatesFilter | string
    foto?: StringWithAggregatesFilter | string
    idCard?: IntWithAggregatesFilter | number
    poder?: IntWithAggregatesFilter | number
  }

  export type inimigoWhereInput = {
    AND?: Enumerable<inimigoWhereInput>
    OR?: Enumerable<inimigoWhereInput>
    NOT?: Enumerable<inimigoWhereInput>
    id?: IntFilter | number
    nome?: StringFilter | string
    foto?: StringFilter | string
    fase?: IntFilter | number
    idUsuario?: IntFilter | number
    idInimigos?: IntFilter | number
    poder?: IntFilter | number
    vida?: IntFilter | number
    inimigos?: XOR<InimigosRelationFilter, inimigosWhereInput>
    usuario?: XOR<UsuarioRelationFilter, usuarioWhereInput>
  }

  export type inimigoOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    foto?: SortOrder
    fase?: SortOrder
    idUsuario?: SortOrder
    idInimigos?: SortOrder
    poder?: SortOrder
    vida?: SortOrder
    inimigos?: inimigosOrderByWithRelationInput
    usuario?: usuarioOrderByWithRelationInput
  }

  export type inimigoWhereUniqueInput = {
    id?: number
  }

  export type inimigoOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    foto?: SortOrder
    fase?: SortOrder
    idUsuario?: SortOrder
    idInimigos?: SortOrder
    poder?: SortOrder
    vida?: SortOrder
    _count?: inimigoCountOrderByAggregateInput
    _avg?: inimigoAvgOrderByAggregateInput
    _max?: inimigoMaxOrderByAggregateInput
    _min?: inimigoMinOrderByAggregateInput
    _sum?: inimigoSumOrderByAggregateInput
  }

  export type inimigoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<inimigoScalarWhereWithAggregatesInput>
    OR?: Enumerable<inimigoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<inimigoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nome?: StringWithAggregatesFilter | string
    foto?: StringWithAggregatesFilter | string
    fase?: IntWithAggregatesFilter | number
    idUsuario?: IntWithAggregatesFilter | number
    idInimigos?: IntWithAggregatesFilter | number
    poder?: IntWithAggregatesFilter | number
    vida?: IntWithAggregatesFilter | number
  }

  export type cardWhereInput = {
    AND?: Enumerable<cardWhereInput>
    OR?: Enumerable<cardWhereInput>
    NOT?: Enumerable<cardWhereInput>
    id?: IntFilter | number
    foto?: StringFilter | string
    poder?: IntFilter | number
    vida?: IntFilter | number
    nome?: StringFilter | string
    deck?: DeckListRelationFilter
    ouroCard?: OuroCardListRelationFilter
  }

  export type cardOrderByWithRelationInput = {
    id?: SortOrder
    foto?: SortOrder
    poder?: SortOrder
    vida?: SortOrder
    nome?: SortOrder
    deck?: deckOrderByRelationAggregateInput
    ouroCard?: ouroCardOrderByRelationAggregateInput
  }

  export type cardWhereUniqueInput = {
    id?: number
  }

  export type cardOrderByWithAggregationInput = {
    id?: SortOrder
    foto?: SortOrder
    poder?: SortOrder
    vida?: SortOrder
    nome?: SortOrder
    _count?: cardCountOrderByAggregateInput
    _avg?: cardAvgOrderByAggregateInput
    _max?: cardMaxOrderByAggregateInput
    _min?: cardMinOrderByAggregateInput
    _sum?: cardSumOrderByAggregateInput
  }

  export type cardScalarWhereWithAggregatesInput = {
    AND?: Enumerable<cardScalarWhereWithAggregatesInput>
    OR?: Enumerable<cardScalarWhereWithAggregatesInput>
    NOT?: Enumerable<cardScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    foto?: StringWithAggregatesFilter | string
    poder?: IntWithAggregatesFilter | number
    vida?: IntWithAggregatesFilter | number
    nome?: StringWithAggregatesFilter | string
  }

  export type usuarioWhereInput = {
    AND?: Enumerable<usuarioWhereInput>
    OR?: Enumerable<usuarioWhereInput>
    NOT?: Enumerable<usuarioWhereInput>
    id?: IntFilter | number
    token?: StringFilter | string
    senha?: StringFilter | string
    email?: StringFilter | string
    foto?: StringFilter | string
    nome?: StringFilter | string
    fase?: IntFilter | number
    deck?: DeckListRelationFilter
    inimigo?: InimigoListRelationFilter
    ouro?: OuroListRelationFilter
    vitorias?: VitoriasListRelationFilter
  }

  export type usuarioOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    senha?: SortOrder
    email?: SortOrder
    foto?: SortOrder
    nome?: SortOrder
    fase?: SortOrder
    deck?: deckOrderByRelationAggregateInput
    inimigo?: inimigoOrderByRelationAggregateInput
    ouro?: ouroOrderByRelationAggregateInput
    vitorias?: vitoriasOrderByRelationAggregateInput
  }

  export type usuarioWhereUniqueInput = {
    id?: number
  }

  export type usuarioOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    senha?: SortOrder
    email?: SortOrder
    foto?: SortOrder
    nome?: SortOrder
    fase?: SortOrder
    _count?: usuarioCountOrderByAggregateInput
    _avg?: usuarioAvgOrderByAggregateInput
    _max?: usuarioMaxOrderByAggregateInput
    _min?: usuarioMinOrderByAggregateInput
    _sum?: usuarioSumOrderByAggregateInput
  }

  export type usuarioScalarWhereWithAggregatesInput = {
    AND?: Enumerable<usuarioScalarWhereWithAggregatesInput>
    OR?: Enumerable<usuarioScalarWhereWithAggregatesInput>
    NOT?: Enumerable<usuarioScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    token?: StringWithAggregatesFilter | string
    senha?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    foto?: StringWithAggregatesFilter | string
    nome?: StringWithAggregatesFilter | string
    fase?: IntWithAggregatesFilter | number
  }

  export type inimigosWhereInput = {
    AND?: Enumerable<inimigosWhereInput>
    OR?: Enumerable<inimigosWhereInput>
    NOT?: Enumerable<inimigosWhereInput>
    id?: IntFilter | number
    poder?: IntFilter | number
    nome?: StringFilter | string
    foto?: StringFilter | string
    vida?: IntFilter | number
    fase?: IntFilter | number
    inimigo?: InimigoListRelationFilter
  }

  export type inimigosOrderByWithRelationInput = {
    id?: SortOrder
    poder?: SortOrder
    nome?: SortOrder
    foto?: SortOrder
    vida?: SortOrder
    fase?: SortOrder
    inimigo?: inimigoOrderByRelationAggregateInput
  }

  export type inimigosWhereUniqueInput = {
    id?: number
  }

  export type inimigosOrderByWithAggregationInput = {
    id?: SortOrder
    poder?: SortOrder
    nome?: SortOrder
    foto?: SortOrder
    vida?: SortOrder
    fase?: SortOrder
    _count?: inimigosCountOrderByAggregateInput
    _avg?: inimigosAvgOrderByAggregateInput
    _max?: inimigosMaxOrderByAggregateInput
    _min?: inimigosMinOrderByAggregateInput
    _sum?: inimigosSumOrderByAggregateInput
  }

  export type inimigosScalarWhereWithAggregatesInput = {
    AND?: Enumerable<inimigosScalarWhereWithAggregatesInput>
    OR?: Enumerable<inimigosScalarWhereWithAggregatesInput>
    NOT?: Enumerable<inimigosScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    poder?: IntWithAggregatesFilter | number
    nome?: StringWithAggregatesFilter | string
    foto?: StringWithAggregatesFilter | string
    vida?: IntWithAggregatesFilter | number
    fase?: IntWithAggregatesFilter | number
  }

  export type vitoriasWhereInput = {
    AND?: Enumerable<vitoriasWhereInput>
    OR?: Enumerable<vitoriasWhereInput>
    NOT?: Enumerable<vitoriasWhereInput>
    id?: IntFilter | number
    vitorias?: IntFilter | number
    usuarioId?: IntFilter | number
    usuario?: XOR<UsuarioRelationFilter, usuarioWhereInput>
  }

  export type vitoriasOrderByWithRelationInput = {
    id?: SortOrder
    vitorias?: SortOrder
    usuarioId?: SortOrder
    usuario?: usuarioOrderByWithRelationInput
  }

  export type vitoriasWhereUniqueInput = {
    id?: number
  }

  export type vitoriasOrderByWithAggregationInput = {
    id?: SortOrder
    vitorias?: SortOrder
    usuarioId?: SortOrder
    _count?: vitoriasCountOrderByAggregateInput
    _avg?: vitoriasAvgOrderByAggregateInput
    _max?: vitoriasMaxOrderByAggregateInput
    _min?: vitoriasMinOrderByAggregateInput
    _sum?: vitoriasSumOrderByAggregateInput
  }

  export type vitoriasScalarWhereWithAggregatesInput = {
    AND?: Enumerable<vitoriasScalarWhereWithAggregatesInput>
    OR?: Enumerable<vitoriasScalarWhereWithAggregatesInput>
    NOT?: Enumerable<vitoriasScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    vitorias?: IntWithAggregatesFilter | number
    usuarioId?: IntWithAggregatesFilter | number
  }

  export type rankingWhereInput = {
    AND?: Enumerable<rankingWhereInput>
    OR?: Enumerable<rankingWhereInput>
    NOT?: Enumerable<rankingWhereInput>
    id?: IntFilter | number
    ranking?: IntFilter | number
    usuarioId?: IntFilter | number
    nome?: StringFilter | string
    foto?: StringFilter | string
  }

  export type rankingOrderByWithRelationInput = {
    id?: SortOrder
    ranking?: SortOrder
    usuarioId?: SortOrder
    nome?: SortOrder
    foto?: SortOrder
  }

  export type rankingWhereUniqueInput = {
    id?: number
  }

  export type rankingOrderByWithAggregationInput = {
    id?: SortOrder
    ranking?: SortOrder
    usuarioId?: SortOrder
    nome?: SortOrder
    foto?: SortOrder
    _count?: rankingCountOrderByAggregateInput
    _avg?: rankingAvgOrderByAggregateInput
    _max?: rankingMaxOrderByAggregateInput
    _min?: rankingMinOrderByAggregateInput
    _sum?: rankingSumOrderByAggregateInput
  }

  export type rankingScalarWhereWithAggregatesInput = {
    AND?: Enumerable<rankingScalarWhereWithAggregatesInput>
    OR?: Enumerable<rankingScalarWhereWithAggregatesInput>
    NOT?: Enumerable<rankingScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    ranking?: IntWithAggregatesFilter | number
    usuarioId?: IntWithAggregatesFilter | number
    nome?: StringWithAggregatesFilter | string
    foto?: StringWithAggregatesFilter | string
  }

  export type ouroWhereInput = {
    AND?: Enumerable<ouroWhereInput>
    OR?: Enumerable<ouroWhereInput>
    NOT?: Enumerable<ouroWhereInput>
    id?: IntFilter | number
    ouro?: IntFilter | number
    usuarioId?: IntFilter | number
    usuario?: XOR<UsuarioRelationFilter, usuarioWhereInput>
  }

  export type ouroOrderByWithRelationInput = {
    id?: SortOrder
    ouro?: SortOrder
    usuarioId?: SortOrder
    usuario?: usuarioOrderByWithRelationInput
  }

  export type ouroWhereUniqueInput = {
    id?: number
  }

  export type ouroOrderByWithAggregationInput = {
    id?: SortOrder
    ouro?: SortOrder
    usuarioId?: SortOrder
    _count?: ouroCountOrderByAggregateInput
    _avg?: ouroAvgOrderByAggregateInput
    _max?: ouroMaxOrderByAggregateInput
    _min?: ouroMinOrderByAggregateInput
    _sum?: ouroSumOrderByAggregateInput
  }

  export type ouroScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ouroScalarWhereWithAggregatesInput>
    OR?: Enumerable<ouroScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ouroScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    ouro?: IntWithAggregatesFilter | number
    usuarioId?: IntWithAggregatesFilter | number
  }

  export type ouroCardWhereInput = {
    AND?: Enumerable<ouroCardWhereInput>
    OR?: Enumerable<ouroCardWhereInput>
    NOT?: Enumerable<ouroCardWhereInput>
    id?: IntFilter | number
    ouro?: IntFilter | number
    cardId?: IntFilter | number
    card?: XOR<CardRelationFilter, cardWhereInput>
  }

  export type ouroCardOrderByWithRelationInput = {
    id?: SortOrder
    ouro?: SortOrder
    cardId?: SortOrder
    card?: cardOrderByWithRelationInput
  }

  export type ouroCardWhereUniqueInput = {
    id?: number
  }

  export type ouroCardOrderByWithAggregationInput = {
    id?: SortOrder
    ouro?: SortOrder
    cardId?: SortOrder
    _count?: ouroCardCountOrderByAggregateInput
    _avg?: ouroCardAvgOrderByAggregateInput
    _max?: ouroCardMaxOrderByAggregateInput
    _min?: ouroCardMinOrderByAggregateInput
    _sum?: ouroCardSumOrderByAggregateInput
  }

  export type ouroCardScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ouroCardScalarWhereWithAggregatesInput>
    OR?: Enumerable<ouroCardScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ouroCardScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    ouro?: IntWithAggregatesFilter | number
    cardId?: IntWithAggregatesFilter | number
  }

  export type deckCreateInput = {
    vida: number
    maxVida: number
    nome: string
    foto: string
    poder: number
    card: cardCreateNestedOneWithoutDeckInput
    usuario: usuarioCreateNestedOneWithoutDeckInput
  }

  export type deckUncheckedCreateInput = {
    id?: number
    idUser: number
    vida: number
    maxVida: number
    nome: string
    foto: string
    idCard: number
    poder: number
  }

  export type deckUpdateInput = {
    vida?: IntFieldUpdateOperationsInput | number
    maxVida?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    foto?: StringFieldUpdateOperationsInput | string
    poder?: IntFieldUpdateOperationsInput | number
    card?: cardUpdateOneRequiredWithoutDeckNestedInput
    usuario?: usuarioUpdateOneRequiredWithoutDeckNestedInput
  }

  export type deckUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    idUser?: IntFieldUpdateOperationsInput | number
    vida?: IntFieldUpdateOperationsInput | number
    maxVida?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    foto?: StringFieldUpdateOperationsInput | string
    idCard?: IntFieldUpdateOperationsInput | number
    poder?: IntFieldUpdateOperationsInput | number
  }

  export type deckCreateManyInput = {
    id?: number
    idUser: number
    vida: number
    maxVida: number
    nome: string
    foto: string
    idCard: number
    poder: number
  }

  export type deckUpdateManyMutationInput = {
    vida?: IntFieldUpdateOperationsInput | number
    maxVida?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    foto?: StringFieldUpdateOperationsInput | string
    poder?: IntFieldUpdateOperationsInput | number
  }

  export type deckUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    idUser?: IntFieldUpdateOperationsInput | number
    vida?: IntFieldUpdateOperationsInput | number
    maxVida?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    foto?: StringFieldUpdateOperationsInput | string
    idCard?: IntFieldUpdateOperationsInput | number
    poder?: IntFieldUpdateOperationsInput | number
  }

  export type inimigoCreateInput = {
    nome: string
    foto: string
    fase: number
    poder: number
    vida: number
    inimigos: inimigosCreateNestedOneWithoutInimigoInput
    usuario: usuarioCreateNestedOneWithoutInimigoInput
  }

  export type inimigoUncheckedCreateInput = {
    id?: number
    nome: string
    foto: string
    fase: number
    idUsuario: number
    idInimigos: number
    poder: number
    vida: number
  }

  export type inimigoUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    foto?: StringFieldUpdateOperationsInput | string
    fase?: IntFieldUpdateOperationsInput | number
    poder?: IntFieldUpdateOperationsInput | number
    vida?: IntFieldUpdateOperationsInput | number
    inimigos?: inimigosUpdateOneRequiredWithoutInimigoNestedInput
    usuario?: usuarioUpdateOneRequiredWithoutInimigoNestedInput
  }

  export type inimigoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    foto?: StringFieldUpdateOperationsInput | string
    fase?: IntFieldUpdateOperationsInput | number
    idUsuario?: IntFieldUpdateOperationsInput | number
    idInimigos?: IntFieldUpdateOperationsInput | number
    poder?: IntFieldUpdateOperationsInput | number
    vida?: IntFieldUpdateOperationsInput | number
  }

  export type inimigoCreateManyInput = {
    id?: number
    nome: string
    foto: string
    fase: number
    idUsuario: number
    idInimigos: number
    poder: number
    vida: number
  }

  export type inimigoUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    foto?: StringFieldUpdateOperationsInput | string
    fase?: IntFieldUpdateOperationsInput | number
    poder?: IntFieldUpdateOperationsInput | number
    vida?: IntFieldUpdateOperationsInput | number
  }

  export type inimigoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    foto?: StringFieldUpdateOperationsInput | string
    fase?: IntFieldUpdateOperationsInput | number
    idUsuario?: IntFieldUpdateOperationsInput | number
    idInimigos?: IntFieldUpdateOperationsInput | number
    poder?: IntFieldUpdateOperationsInput | number
    vida?: IntFieldUpdateOperationsInput | number
  }

  export type cardCreateInput = {
    foto: string
    poder: number
    vida: number
    nome: string
    deck?: deckCreateNestedManyWithoutCardInput
    ouroCard?: ouroCardCreateNestedManyWithoutCardInput
  }

  export type cardUncheckedCreateInput = {
    id?: number
    foto: string
    poder: number
    vida: number
    nome: string
    deck?: deckUncheckedCreateNestedManyWithoutCardInput
    ouroCard?: ouroCardUncheckedCreateNestedManyWithoutCardInput
  }

  export type cardUpdateInput = {
    foto?: StringFieldUpdateOperationsInput | string
    poder?: IntFieldUpdateOperationsInput | number
    vida?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    deck?: deckUpdateManyWithoutCardNestedInput
    ouroCard?: ouroCardUpdateManyWithoutCardNestedInput
  }

  export type cardUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    foto?: StringFieldUpdateOperationsInput | string
    poder?: IntFieldUpdateOperationsInput | number
    vida?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    deck?: deckUncheckedUpdateManyWithoutCardNestedInput
    ouroCard?: ouroCardUncheckedUpdateManyWithoutCardNestedInput
  }

  export type cardCreateManyInput = {
    id?: number
    foto: string
    poder: number
    vida: number
    nome: string
  }

  export type cardUpdateManyMutationInput = {
    foto?: StringFieldUpdateOperationsInput | string
    poder?: IntFieldUpdateOperationsInput | number
    vida?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
  }

  export type cardUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    foto?: StringFieldUpdateOperationsInput | string
    poder?: IntFieldUpdateOperationsInput | number
    vida?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
  }

  export type usuarioCreateInput = {
    token: string
    senha: string
    email: string
    foto: string
    nome: string
    fase: number
    deck?: deckCreateNestedManyWithoutUsuarioInput
    inimigo?: inimigoCreateNestedManyWithoutUsuarioInput
    ouro?: ouroCreateNestedManyWithoutUsuarioInput
    vitorias?: vitoriasCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioUncheckedCreateInput = {
    id?: number
    token: string
    senha: string
    email: string
    foto: string
    nome: string
    fase: number
    deck?: deckUncheckedCreateNestedManyWithoutUsuarioInput
    inimigo?: inimigoUncheckedCreateNestedManyWithoutUsuarioInput
    ouro?: ouroUncheckedCreateNestedManyWithoutUsuarioInput
    vitorias?: vitoriasUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    foto?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    fase?: IntFieldUpdateOperationsInput | number
    deck?: deckUpdateManyWithoutUsuarioNestedInput
    inimigo?: inimigoUpdateManyWithoutUsuarioNestedInput
    ouro?: ouroUpdateManyWithoutUsuarioNestedInput
    vitorias?: vitoriasUpdateManyWithoutUsuarioNestedInput
  }

  export type usuarioUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    foto?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    fase?: IntFieldUpdateOperationsInput | number
    deck?: deckUncheckedUpdateManyWithoutUsuarioNestedInput
    inimigo?: inimigoUncheckedUpdateManyWithoutUsuarioNestedInput
    ouro?: ouroUncheckedUpdateManyWithoutUsuarioNestedInput
    vitorias?: vitoriasUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type usuarioCreateManyInput = {
    id?: number
    token: string
    senha: string
    email: string
    foto: string
    nome: string
    fase: number
  }

  export type usuarioUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    foto?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    fase?: IntFieldUpdateOperationsInput | number
  }

  export type usuarioUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    foto?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    fase?: IntFieldUpdateOperationsInput | number
  }

  export type inimigosCreateInput = {
    poder: number
    nome: string
    foto: string
    vida: number
    fase: number
    inimigo?: inimigoCreateNestedManyWithoutInimigosInput
  }

  export type inimigosUncheckedCreateInput = {
    id?: number
    poder: number
    nome: string
    foto: string
    vida: number
    fase: number
    inimigo?: inimigoUncheckedCreateNestedManyWithoutInimigosInput
  }

  export type inimigosUpdateInput = {
    poder?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    foto?: StringFieldUpdateOperationsInput | string
    vida?: IntFieldUpdateOperationsInput | number
    fase?: IntFieldUpdateOperationsInput | number
    inimigo?: inimigoUpdateManyWithoutInimigosNestedInput
  }

  export type inimigosUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    poder?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    foto?: StringFieldUpdateOperationsInput | string
    vida?: IntFieldUpdateOperationsInput | number
    fase?: IntFieldUpdateOperationsInput | number
    inimigo?: inimigoUncheckedUpdateManyWithoutInimigosNestedInput
  }

  export type inimigosCreateManyInput = {
    id?: number
    poder: number
    nome: string
    foto: string
    vida: number
    fase: number
  }

  export type inimigosUpdateManyMutationInput = {
    poder?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    foto?: StringFieldUpdateOperationsInput | string
    vida?: IntFieldUpdateOperationsInput | number
    fase?: IntFieldUpdateOperationsInput | number
  }

  export type inimigosUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    poder?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    foto?: StringFieldUpdateOperationsInput | string
    vida?: IntFieldUpdateOperationsInput | number
    fase?: IntFieldUpdateOperationsInput | number
  }

  export type vitoriasCreateInput = {
    vitorias: number
    usuario: usuarioCreateNestedOneWithoutVitoriasInput
  }

  export type vitoriasUncheckedCreateInput = {
    id?: number
    vitorias: number
    usuarioId: number
  }

  export type vitoriasUpdateInput = {
    vitorias?: IntFieldUpdateOperationsInput | number
    usuario?: usuarioUpdateOneRequiredWithoutVitoriasNestedInput
  }

  export type vitoriasUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    vitorias?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
  }

  export type vitoriasCreateManyInput = {
    id?: number
    vitorias: number
    usuarioId: number
  }

  export type vitoriasUpdateManyMutationInput = {
    vitorias?: IntFieldUpdateOperationsInput | number
  }

  export type vitoriasUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    vitorias?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
  }

  export type rankingCreateInput = {
    ranking: number
    usuarioId: number
    nome: string
    foto: string
  }

  export type rankingUncheckedCreateInput = {
    id?: number
    ranking: number
    usuarioId: number
    nome: string
    foto: string
  }

  export type rankingUpdateInput = {
    ranking?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    foto?: StringFieldUpdateOperationsInput | string
  }

  export type rankingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ranking?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    foto?: StringFieldUpdateOperationsInput | string
  }

  export type rankingCreateManyInput = {
    id?: number
    ranking: number
    usuarioId: number
    nome: string
    foto: string
  }

  export type rankingUpdateManyMutationInput = {
    ranking?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    foto?: StringFieldUpdateOperationsInput | string
  }

  export type rankingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ranking?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    foto?: StringFieldUpdateOperationsInput | string
  }

  export type ouroCreateInput = {
    ouro: number
    usuario: usuarioCreateNestedOneWithoutOuroInput
  }

  export type ouroUncheckedCreateInput = {
    id?: number
    ouro: number
    usuarioId: number
  }

  export type ouroUpdateInput = {
    ouro?: IntFieldUpdateOperationsInput | number
    usuario?: usuarioUpdateOneRequiredWithoutOuroNestedInput
  }

  export type ouroUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ouro?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
  }

  export type ouroCreateManyInput = {
    id?: number
    ouro: number
    usuarioId: number
  }

  export type ouroUpdateManyMutationInput = {
    ouro?: IntFieldUpdateOperationsInput | number
  }

  export type ouroUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ouro?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
  }

  export type ouroCardCreateInput = {
    ouro: number
    card: cardCreateNestedOneWithoutOuroCardInput
  }

  export type ouroCardUncheckedCreateInput = {
    id?: number
    ouro: number
    cardId: number
  }

  export type ouroCardUpdateInput = {
    ouro?: IntFieldUpdateOperationsInput | number
    card?: cardUpdateOneRequiredWithoutOuroCardNestedInput
  }

  export type ouroCardUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ouro?: IntFieldUpdateOperationsInput | number
    cardId?: IntFieldUpdateOperationsInput | number
  }

  export type ouroCardCreateManyInput = {
    id?: number
    ouro: number
    cardId: number
  }

  export type ouroCardUpdateManyMutationInput = {
    ouro?: IntFieldUpdateOperationsInput | number
  }

  export type ouroCardUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ouro?: IntFieldUpdateOperationsInput | number
    cardId?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type CardRelationFilter = {
    is?: cardWhereInput
    isNot?: cardWhereInput
  }

  export type UsuarioRelationFilter = {
    is?: usuarioWhereInput
    isNot?: usuarioWhereInput
  }

  export type deckCountOrderByAggregateInput = {
    id?: SortOrder
    idUser?: SortOrder
    vida?: SortOrder
    maxVida?: SortOrder
    nome?: SortOrder
    foto?: SortOrder
    idCard?: SortOrder
    poder?: SortOrder
  }

  export type deckAvgOrderByAggregateInput = {
    id?: SortOrder
    idUser?: SortOrder
    vida?: SortOrder
    maxVida?: SortOrder
    idCard?: SortOrder
    poder?: SortOrder
  }

  export type deckMaxOrderByAggregateInput = {
    id?: SortOrder
    idUser?: SortOrder
    vida?: SortOrder
    maxVida?: SortOrder
    nome?: SortOrder
    foto?: SortOrder
    idCard?: SortOrder
    poder?: SortOrder
  }

  export type deckMinOrderByAggregateInput = {
    id?: SortOrder
    idUser?: SortOrder
    vida?: SortOrder
    maxVida?: SortOrder
    nome?: SortOrder
    foto?: SortOrder
    idCard?: SortOrder
    poder?: SortOrder
  }

  export type deckSumOrderByAggregateInput = {
    id?: SortOrder
    idUser?: SortOrder
    vida?: SortOrder
    maxVida?: SortOrder
    idCard?: SortOrder
    poder?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type InimigosRelationFilter = {
    is?: inimigosWhereInput
    isNot?: inimigosWhereInput
  }

  export type inimigoCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    foto?: SortOrder
    fase?: SortOrder
    idUsuario?: SortOrder
    idInimigos?: SortOrder
    poder?: SortOrder
    vida?: SortOrder
  }

  export type inimigoAvgOrderByAggregateInput = {
    id?: SortOrder
    fase?: SortOrder
    idUsuario?: SortOrder
    idInimigos?: SortOrder
    poder?: SortOrder
    vida?: SortOrder
  }

  export type inimigoMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    foto?: SortOrder
    fase?: SortOrder
    idUsuario?: SortOrder
    idInimigos?: SortOrder
    poder?: SortOrder
    vida?: SortOrder
  }

  export type inimigoMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    foto?: SortOrder
    fase?: SortOrder
    idUsuario?: SortOrder
    idInimigos?: SortOrder
    poder?: SortOrder
    vida?: SortOrder
  }

  export type inimigoSumOrderByAggregateInput = {
    id?: SortOrder
    fase?: SortOrder
    idUsuario?: SortOrder
    idInimigos?: SortOrder
    poder?: SortOrder
    vida?: SortOrder
  }

  export type DeckListRelationFilter = {
    every?: deckWhereInput
    some?: deckWhereInput
    none?: deckWhereInput
  }

  export type OuroCardListRelationFilter = {
    every?: ouroCardWhereInput
    some?: ouroCardWhereInput
    none?: ouroCardWhereInput
  }

  export type deckOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ouroCardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type cardCountOrderByAggregateInput = {
    id?: SortOrder
    foto?: SortOrder
    poder?: SortOrder
    vida?: SortOrder
    nome?: SortOrder
  }

  export type cardAvgOrderByAggregateInput = {
    id?: SortOrder
    poder?: SortOrder
    vida?: SortOrder
  }

  export type cardMaxOrderByAggregateInput = {
    id?: SortOrder
    foto?: SortOrder
    poder?: SortOrder
    vida?: SortOrder
    nome?: SortOrder
  }

  export type cardMinOrderByAggregateInput = {
    id?: SortOrder
    foto?: SortOrder
    poder?: SortOrder
    vida?: SortOrder
    nome?: SortOrder
  }

  export type cardSumOrderByAggregateInput = {
    id?: SortOrder
    poder?: SortOrder
    vida?: SortOrder
  }

  export type InimigoListRelationFilter = {
    every?: inimigoWhereInput
    some?: inimigoWhereInput
    none?: inimigoWhereInput
  }

  export type OuroListRelationFilter = {
    every?: ouroWhereInput
    some?: ouroWhereInput
    none?: ouroWhereInput
  }

  export type VitoriasListRelationFilter = {
    every?: vitoriasWhereInput
    some?: vitoriasWhereInput
    none?: vitoriasWhereInput
  }

  export type inimigoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ouroOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type vitoriasOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usuarioCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    senha?: SortOrder
    email?: SortOrder
    foto?: SortOrder
    nome?: SortOrder
    fase?: SortOrder
  }

  export type usuarioAvgOrderByAggregateInput = {
    id?: SortOrder
    fase?: SortOrder
  }

  export type usuarioMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    senha?: SortOrder
    email?: SortOrder
    foto?: SortOrder
    nome?: SortOrder
    fase?: SortOrder
  }

  export type usuarioMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    senha?: SortOrder
    email?: SortOrder
    foto?: SortOrder
    nome?: SortOrder
    fase?: SortOrder
  }

  export type usuarioSumOrderByAggregateInput = {
    id?: SortOrder
    fase?: SortOrder
  }

  export type inimigosCountOrderByAggregateInput = {
    id?: SortOrder
    poder?: SortOrder
    nome?: SortOrder
    foto?: SortOrder
    vida?: SortOrder
    fase?: SortOrder
  }

  export type inimigosAvgOrderByAggregateInput = {
    id?: SortOrder
    poder?: SortOrder
    vida?: SortOrder
    fase?: SortOrder
  }

  export type inimigosMaxOrderByAggregateInput = {
    id?: SortOrder
    poder?: SortOrder
    nome?: SortOrder
    foto?: SortOrder
    vida?: SortOrder
    fase?: SortOrder
  }

  export type inimigosMinOrderByAggregateInput = {
    id?: SortOrder
    poder?: SortOrder
    nome?: SortOrder
    foto?: SortOrder
    vida?: SortOrder
    fase?: SortOrder
  }

  export type inimigosSumOrderByAggregateInput = {
    id?: SortOrder
    poder?: SortOrder
    vida?: SortOrder
    fase?: SortOrder
  }

  export type vitoriasCountOrderByAggregateInput = {
    id?: SortOrder
    vitorias?: SortOrder
    usuarioId?: SortOrder
  }

  export type vitoriasAvgOrderByAggregateInput = {
    id?: SortOrder
    vitorias?: SortOrder
    usuarioId?: SortOrder
  }

  export type vitoriasMaxOrderByAggregateInput = {
    id?: SortOrder
    vitorias?: SortOrder
    usuarioId?: SortOrder
  }

  export type vitoriasMinOrderByAggregateInput = {
    id?: SortOrder
    vitorias?: SortOrder
    usuarioId?: SortOrder
  }

  export type vitoriasSumOrderByAggregateInput = {
    id?: SortOrder
    vitorias?: SortOrder
    usuarioId?: SortOrder
  }

  export type rankingCountOrderByAggregateInput = {
    id?: SortOrder
    ranking?: SortOrder
    usuarioId?: SortOrder
    nome?: SortOrder
    foto?: SortOrder
  }

  export type rankingAvgOrderByAggregateInput = {
    id?: SortOrder
    ranking?: SortOrder
    usuarioId?: SortOrder
  }

  export type rankingMaxOrderByAggregateInput = {
    id?: SortOrder
    ranking?: SortOrder
    usuarioId?: SortOrder
    nome?: SortOrder
    foto?: SortOrder
  }

  export type rankingMinOrderByAggregateInput = {
    id?: SortOrder
    ranking?: SortOrder
    usuarioId?: SortOrder
    nome?: SortOrder
    foto?: SortOrder
  }

  export type rankingSumOrderByAggregateInput = {
    id?: SortOrder
    ranking?: SortOrder
    usuarioId?: SortOrder
  }

  export type ouroCountOrderByAggregateInput = {
    id?: SortOrder
    ouro?: SortOrder
    usuarioId?: SortOrder
  }

  export type ouroAvgOrderByAggregateInput = {
    id?: SortOrder
    ouro?: SortOrder
    usuarioId?: SortOrder
  }

  export type ouroMaxOrderByAggregateInput = {
    id?: SortOrder
    ouro?: SortOrder
    usuarioId?: SortOrder
  }

  export type ouroMinOrderByAggregateInput = {
    id?: SortOrder
    ouro?: SortOrder
    usuarioId?: SortOrder
  }

  export type ouroSumOrderByAggregateInput = {
    id?: SortOrder
    ouro?: SortOrder
    usuarioId?: SortOrder
  }

  export type ouroCardCountOrderByAggregateInput = {
    id?: SortOrder
    ouro?: SortOrder
    cardId?: SortOrder
  }

  export type ouroCardAvgOrderByAggregateInput = {
    id?: SortOrder
    ouro?: SortOrder
    cardId?: SortOrder
  }

  export type ouroCardMaxOrderByAggregateInput = {
    id?: SortOrder
    ouro?: SortOrder
    cardId?: SortOrder
  }

  export type ouroCardMinOrderByAggregateInput = {
    id?: SortOrder
    ouro?: SortOrder
    cardId?: SortOrder
  }

  export type ouroCardSumOrderByAggregateInput = {
    id?: SortOrder
    ouro?: SortOrder
    cardId?: SortOrder
  }

  export type cardCreateNestedOneWithoutDeckInput = {
    create?: XOR<cardCreateWithoutDeckInput, cardUncheckedCreateWithoutDeckInput>
    connectOrCreate?: cardCreateOrConnectWithoutDeckInput
    connect?: cardWhereUniqueInput
  }

  export type usuarioCreateNestedOneWithoutDeckInput = {
    create?: XOR<usuarioCreateWithoutDeckInput, usuarioUncheckedCreateWithoutDeckInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutDeckInput
    connect?: usuarioWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type cardUpdateOneRequiredWithoutDeckNestedInput = {
    create?: XOR<cardCreateWithoutDeckInput, cardUncheckedCreateWithoutDeckInput>
    connectOrCreate?: cardCreateOrConnectWithoutDeckInput
    upsert?: cardUpsertWithoutDeckInput
    connect?: cardWhereUniqueInput
    update?: XOR<cardUpdateWithoutDeckInput, cardUncheckedUpdateWithoutDeckInput>
  }

  export type usuarioUpdateOneRequiredWithoutDeckNestedInput = {
    create?: XOR<usuarioCreateWithoutDeckInput, usuarioUncheckedCreateWithoutDeckInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutDeckInput
    upsert?: usuarioUpsertWithoutDeckInput
    connect?: usuarioWhereUniqueInput
    update?: XOR<usuarioUpdateWithoutDeckInput, usuarioUncheckedUpdateWithoutDeckInput>
  }

  export type inimigosCreateNestedOneWithoutInimigoInput = {
    create?: XOR<inimigosCreateWithoutInimigoInput, inimigosUncheckedCreateWithoutInimigoInput>
    connectOrCreate?: inimigosCreateOrConnectWithoutInimigoInput
    connect?: inimigosWhereUniqueInput
  }

  export type usuarioCreateNestedOneWithoutInimigoInput = {
    create?: XOR<usuarioCreateWithoutInimigoInput, usuarioUncheckedCreateWithoutInimigoInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutInimigoInput
    connect?: usuarioWhereUniqueInput
  }

  export type inimigosUpdateOneRequiredWithoutInimigoNestedInput = {
    create?: XOR<inimigosCreateWithoutInimigoInput, inimigosUncheckedCreateWithoutInimigoInput>
    connectOrCreate?: inimigosCreateOrConnectWithoutInimigoInput
    upsert?: inimigosUpsertWithoutInimigoInput
    connect?: inimigosWhereUniqueInput
    update?: XOR<inimigosUpdateWithoutInimigoInput, inimigosUncheckedUpdateWithoutInimigoInput>
  }

  export type usuarioUpdateOneRequiredWithoutInimigoNestedInput = {
    create?: XOR<usuarioCreateWithoutInimigoInput, usuarioUncheckedCreateWithoutInimigoInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutInimigoInput
    upsert?: usuarioUpsertWithoutInimigoInput
    connect?: usuarioWhereUniqueInput
    update?: XOR<usuarioUpdateWithoutInimigoInput, usuarioUncheckedUpdateWithoutInimigoInput>
  }

  export type deckCreateNestedManyWithoutCardInput = {
    create?: XOR<Enumerable<deckCreateWithoutCardInput>, Enumerable<deckUncheckedCreateWithoutCardInput>>
    connectOrCreate?: Enumerable<deckCreateOrConnectWithoutCardInput>
    createMany?: deckCreateManyCardInputEnvelope
    connect?: Enumerable<deckWhereUniqueInput>
  }

  export type ouroCardCreateNestedManyWithoutCardInput = {
    create?: XOR<Enumerable<ouroCardCreateWithoutCardInput>, Enumerable<ouroCardUncheckedCreateWithoutCardInput>>
    connectOrCreate?: Enumerable<ouroCardCreateOrConnectWithoutCardInput>
    createMany?: ouroCardCreateManyCardInputEnvelope
    connect?: Enumerable<ouroCardWhereUniqueInput>
  }

  export type deckUncheckedCreateNestedManyWithoutCardInput = {
    create?: XOR<Enumerable<deckCreateWithoutCardInput>, Enumerable<deckUncheckedCreateWithoutCardInput>>
    connectOrCreate?: Enumerable<deckCreateOrConnectWithoutCardInput>
    createMany?: deckCreateManyCardInputEnvelope
    connect?: Enumerable<deckWhereUniqueInput>
  }

  export type ouroCardUncheckedCreateNestedManyWithoutCardInput = {
    create?: XOR<Enumerable<ouroCardCreateWithoutCardInput>, Enumerable<ouroCardUncheckedCreateWithoutCardInput>>
    connectOrCreate?: Enumerable<ouroCardCreateOrConnectWithoutCardInput>
    createMany?: ouroCardCreateManyCardInputEnvelope
    connect?: Enumerable<ouroCardWhereUniqueInput>
  }

  export type deckUpdateManyWithoutCardNestedInput = {
    create?: XOR<Enumerable<deckCreateWithoutCardInput>, Enumerable<deckUncheckedCreateWithoutCardInput>>
    connectOrCreate?: Enumerable<deckCreateOrConnectWithoutCardInput>
    upsert?: Enumerable<deckUpsertWithWhereUniqueWithoutCardInput>
    createMany?: deckCreateManyCardInputEnvelope
    set?: Enumerable<deckWhereUniqueInput>
    disconnect?: Enumerable<deckWhereUniqueInput>
    delete?: Enumerable<deckWhereUniqueInput>
    connect?: Enumerable<deckWhereUniqueInput>
    update?: Enumerable<deckUpdateWithWhereUniqueWithoutCardInput>
    updateMany?: Enumerable<deckUpdateManyWithWhereWithoutCardInput>
    deleteMany?: Enumerable<deckScalarWhereInput>
  }

  export type ouroCardUpdateManyWithoutCardNestedInput = {
    create?: XOR<Enumerable<ouroCardCreateWithoutCardInput>, Enumerable<ouroCardUncheckedCreateWithoutCardInput>>
    connectOrCreate?: Enumerable<ouroCardCreateOrConnectWithoutCardInput>
    upsert?: Enumerable<ouroCardUpsertWithWhereUniqueWithoutCardInput>
    createMany?: ouroCardCreateManyCardInputEnvelope
    set?: Enumerable<ouroCardWhereUniqueInput>
    disconnect?: Enumerable<ouroCardWhereUniqueInput>
    delete?: Enumerable<ouroCardWhereUniqueInput>
    connect?: Enumerable<ouroCardWhereUniqueInput>
    update?: Enumerable<ouroCardUpdateWithWhereUniqueWithoutCardInput>
    updateMany?: Enumerable<ouroCardUpdateManyWithWhereWithoutCardInput>
    deleteMany?: Enumerable<ouroCardScalarWhereInput>
  }

  export type deckUncheckedUpdateManyWithoutCardNestedInput = {
    create?: XOR<Enumerable<deckCreateWithoutCardInput>, Enumerable<deckUncheckedCreateWithoutCardInput>>
    connectOrCreate?: Enumerable<deckCreateOrConnectWithoutCardInput>
    upsert?: Enumerable<deckUpsertWithWhereUniqueWithoutCardInput>
    createMany?: deckCreateManyCardInputEnvelope
    set?: Enumerable<deckWhereUniqueInput>
    disconnect?: Enumerable<deckWhereUniqueInput>
    delete?: Enumerable<deckWhereUniqueInput>
    connect?: Enumerable<deckWhereUniqueInput>
    update?: Enumerable<deckUpdateWithWhereUniqueWithoutCardInput>
    updateMany?: Enumerable<deckUpdateManyWithWhereWithoutCardInput>
    deleteMany?: Enumerable<deckScalarWhereInput>
  }

  export type ouroCardUncheckedUpdateManyWithoutCardNestedInput = {
    create?: XOR<Enumerable<ouroCardCreateWithoutCardInput>, Enumerable<ouroCardUncheckedCreateWithoutCardInput>>
    connectOrCreate?: Enumerable<ouroCardCreateOrConnectWithoutCardInput>
    upsert?: Enumerable<ouroCardUpsertWithWhereUniqueWithoutCardInput>
    createMany?: ouroCardCreateManyCardInputEnvelope
    set?: Enumerable<ouroCardWhereUniqueInput>
    disconnect?: Enumerable<ouroCardWhereUniqueInput>
    delete?: Enumerable<ouroCardWhereUniqueInput>
    connect?: Enumerable<ouroCardWhereUniqueInput>
    update?: Enumerable<ouroCardUpdateWithWhereUniqueWithoutCardInput>
    updateMany?: Enumerable<ouroCardUpdateManyWithWhereWithoutCardInput>
    deleteMany?: Enumerable<ouroCardScalarWhereInput>
  }

  export type deckCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<Enumerable<deckCreateWithoutUsuarioInput>, Enumerable<deckUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<deckCreateOrConnectWithoutUsuarioInput>
    createMany?: deckCreateManyUsuarioInputEnvelope
    connect?: Enumerable<deckWhereUniqueInput>
  }

  export type inimigoCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<Enumerable<inimigoCreateWithoutUsuarioInput>, Enumerable<inimigoUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<inimigoCreateOrConnectWithoutUsuarioInput>
    createMany?: inimigoCreateManyUsuarioInputEnvelope
    connect?: Enumerable<inimigoWhereUniqueInput>
  }

  export type ouroCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<Enumerable<ouroCreateWithoutUsuarioInput>, Enumerable<ouroUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<ouroCreateOrConnectWithoutUsuarioInput>
    createMany?: ouroCreateManyUsuarioInputEnvelope
    connect?: Enumerable<ouroWhereUniqueInput>
  }

  export type vitoriasCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<Enumerable<vitoriasCreateWithoutUsuarioInput>, Enumerable<vitoriasUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<vitoriasCreateOrConnectWithoutUsuarioInput>
    createMany?: vitoriasCreateManyUsuarioInputEnvelope
    connect?: Enumerable<vitoriasWhereUniqueInput>
  }

  export type deckUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<Enumerable<deckCreateWithoutUsuarioInput>, Enumerable<deckUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<deckCreateOrConnectWithoutUsuarioInput>
    createMany?: deckCreateManyUsuarioInputEnvelope
    connect?: Enumerable<deckWhereUniqueInput>
  }

  export type inimigoUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<Enumerable<inimigoCreateWithoutUsuarioInput>, Enumerable<inimigoUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<inimigoCreateOrConnectWithoutUsuarioInput>
    createMany?: inimigoCreateManyUsuarioInputEnvelope
    connect?: Enumerable<inimigoWhereUniqueInput>
  }

  export type ouroUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<Enumerable<ouroCreateWithoutUsuarioInput>, Enumerable<ouroUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<ouroCreateOrConnectWithoutUsuarioInput>
    createMany?: ouroCreateManyUsuarioInputEnvelope
    connect?: Enumerable<ouroWhereUniqueInput>
  }

  export type vitoriasUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<Enumerable<vitoriasCreateWithoutUsuarioInput>, Enumerable<vitoriasUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<vitoriasCreateOrConnectWithoutUsuarioInput>
    createMany?: vitoriasCreateManyUsuarioInputEnvelope
    connect?: Enumerable<vitoriasWhereUniqueInput>
  }

  export type deckUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<Enumerable<deckCreateWithoutUsuarioInput>, Enumerable<deckUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<deckCreateOrConnectWithoutUsuarioInput>
    upsert?: Enumerable<deckUpsertWithWhereUniqueWithoutUsuarioInput>
    createMany?: deckCreateManyUsuarioInputEnvelope
    set?: Enumerable<deckWhereUniqueInput>
    disconnect?: Enumerable<deckWhereUniqueInput>
    delete?: Enumerable<deckWhereUniqueInput>
    connect?: Enumerable<deckWhereUniqueInput>
    update?: Enumerable<deckUpdateWithWhereUniqueWithoutUsuarioInput>
    updateMany?: Enumerable<deckUpdateManyWithWhereWithoutUsuarioInput>
    deleteMany?: Enumerable<deckScalarWhereInput>
  }

  export type inimigoUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<Enumerable<inimigoCreateWithoutUsuarioInput>, Enumerable<inimigoUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<inimigoCreateOrConnectWithoutUsuarioInput>
    upsert?: Enumerable<inimigoUpsertWithWhereUniqueWithoutUsuarioInput>
    createMany?: inimigoCreateManyUsuarioInputEnvelope
    set?: Enumerable<inimigoWhereUniqueInput>
    disconnect?: Enumerable<inimigoWhereUniqueInput>
    delete?: Enumerable<inimigoWhereUniqueInput>
    connect?: Enumerable<inimigoWhereUniqueInput>
    update?: Enumerable<inimigoUpdateWithWhereUniqueWithoutUsuarioInput>
    updateMany?: Enumerable<inimigoUpdateManyWithWhereWithoutUsuarioInput>
    deleteMany?: Enumerable<inimigoScalarWhereInput>
  }

  export type ouroUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<Enumerable<ouroCreateWithoutUsuarioInput>, Enumerable<ouroUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<ouroCreateOrConnectWithoutUsuarioInput>
    upsert?: Enumerable<ouroUpsertWithWhereUniqueWithoutUsuarioInput>
    createMany?: ouroCreateManyUsuarioInputEnvelope
    set?: Enumerable<ouroWhereUniqueInput>
    disconnect?: Enumerable<ouroWhereUniqueInput>
    delete?: Enumerable<ouroWhereUniqueInput>
    connect?: Enumerable<ouroWhereUniqueInput>
    update?: Enumerable<ouroUpdateWithWhereUniqueWithoutUsuarioInput>
    updateMany?: Enumerable<ouroUpdateManyWithWhereWithoutUsuarioInput>
    deleteMany?: Enumerable<ouroScalarWhereInput>
  }

  export type vitoriasUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<Enumerable<vitoriasCreateWithoutUsuarioInput>, Enumerable<vitoriasUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<vitoriasCreateOrConnectWithoutUsuarioInput>
    upsert?: Enumerable<vitoriasUpsertWithWhereUniqueWithoutUsuarioInput>
    createMany?: vitoriasCreateManyUsuarioInputEnvelope
    set?: Enumerable<vitoriasWhereUniqueInput>
    disconnect?: Enumerable<vitoriasWhereUniqueInput>
    delete?: Enumerable<vitoriasWhereUniqueInput>
    connect?: Enumerable<vitoriasWhereUniqueInput>
    update?: Enumerable<vitoriasUpdateWithWhereUniqueWithoutUsuarioInput>
    updateMany?: Enumerable<vitoriasUpdateManyWithWhereWithoutUsuarioInput>
    deleteMany?: Enumerable<vitoriasScalarWhereInput>
  }

  export type deckUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<Enumerable<deckCreateWithoutUsuarioInput>, Enumerable<deckUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<deckCreateOrConnectWithoutUsuarioInput>
    upsert?: Enumerable<deckUpsertWithWhereUniqueWithoutUsuarioInput>
    createMany?: deckCreateManyUsuarioInputEnvelope
    set?: Enumerable<deckWhereUniqueInput>
    disconnect?: Enumerable<deckWhereUniqueInput>
    delete?: Enumerable<deckWhereUniqueInput>
    connect?: Enumerable<deckWhereUniqueInput>
    update?: Enumerable<deckUpdateWithWhereUniqueWithoutUsuarioInput>
    updateMany?: Enumerable<deckUpdateManyWithWhereWithoutUsuarioInput>
    deleteMany?: Enumerable<deckScalarWhereInput>
  }

  export type inimigoUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<Enumerable<inimigoCreateWithoutUsuarioInput>, Enumerable<inimigoUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<inimigoCreateOrConnectWithoutUsuarioInput>
    upsert?: Enumerable<inimigoUpsertWithWhereUniqueWithoutUsuarioInput>
    createMany?: inimigoCreateManyUsuarioInputEnvelope
    set?: Enumerable<inimigoWhereUniqueInput>
    disconnect?: Enumerable<inimigoWhereUniqueInput>
    delete?: Enumerable<inimigoWhereUniqueInput>
    connect?: Enumerable<inimigoWhereUniqueInput>
    update?: Enumerable<inimigoUpdateWithWhereUniqueWithoutUsuarioInput>
    updateMany?: Enumerable<inimigoUpdateManyWithWhereWithoutUsuarioInput>
    deleteMany?: Enumerable<inimigoScalarWhereInput>
  }

  export type ouroUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<Enumerable<ouroCreateWithoutUsuarioInput>, Enumerable<ouroUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<ouroCreateOrConnectWithoutUsuarioInput>
    upsert?: Enumerable<ouroUpsertWithWhereUniqueWithoutUsuarioInput>
    createMany?: ouroCreateManyUsuarioInputEnvelope
    set?: Enumerable<ouroWhereUniqueInput>
    disconnect?: Enumerable<ouroWhereUniqueInput>
    delete?: Enumerable<ouroWhereUniqueInput>
    connect?: Enumerable<ouroWhereUniqueInput>
    update?: Enumerable<ouroUpdateWithWhereUniqueWithoutUsuarioInput>
    updateMany?: Enumerable<ouroUpdateManyWithWhereWithoutUsuarioInput>
    deleteMany?: Enumerable<ouroScalarWhereInput>
  }

  export type vitoriasUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<Enumerable<vitoriasCreateWithoutUsuarioInput>, Enumerable<vitoriasUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<vitoriasCreateOrConnectWithoutUsuarioInput>
    upsert?: Enumerable<vitoriasUpsertWithWhereUniqueWithoutUsuarioInput>
    createMany?: vitoriasCreateManyUsuarioInputEnvelope
    set?: Enumerable<vitoriasWhereUniqueInput>
    disconnect?: Enumerable<vitoriasWhereUniqueInput>
    delete?: Enumerable<vitoriasWhereUniqueInput>
    connect?: Enumerable<vitoriasWhereUniqueInput>
    update?: Enumerable<vitoriasUpdateWithWhereUniqueWithoutUsuarioInput>
    updateMany?: Enumerable<vitoriasUpdateManyWithWhereWithoutUsuarioInput>
    deleteMany?: Enumerable<vitoriasScalarWhereInput>
  }

  export type inimigoCreateNestedManyWithoutInimigosInput = {
    create?: XOR<Enumerable<inimigoCreateWithoutInimigosInput>, Enumerable<inimigoUncheckedCreateWithoutInimigosInput>>
    connectOrCreate?: Enumerable<inimigoCreateOrConnectWithoutInimigosInput>
    createMany?: inimigoCreateManyInimigosInputEnvelope
    connect?: Enumerable<inimigoWhereUniqueInput>
  }

  export type inimigoUncheckedCreateNestedManyWithoutInimigosInput = {
    create?: XOR<Enumerable<inimigoCreateWithoutInimigosInput>, Enumerable<inimigoUncheckedCreateWithoutInimigosInput>>
    connectOrCreate?: Enumerable<inimigoCreateOrConnectWithoutInimigosInput>
    createMany?: inimigoCreateManyInimigosInputEnvelope
    connect?: Enumerable<inimigoWhereUniqueInput>
  }

  export type inimigoUpdateManyWithoutInimigosNestedInput = {
    create?: XOR<Enumerable<inimigoCreateWithoutInimigosInput>, Enumerable<inimigoUncheckedCreateWithoutInimigosInput>>
    connectOrCreate?: Enumerable<inimigoCreateOrConnectWithoutInimigosInput>
    upsert?: Enumerable<inimigoUpsertWithWhereUniqueWithoutInimigosInput>
    createMany?: inimigoCreateManyInimigosInputEnvelope
    set?: Enumerable<inimigoWhereUniqueInput>
    disconnect?: Enumerable<inimigoWhereUniqueInput>
    delete?: Enumerable<inimigoWhereUniqueInput>
    connect?: Enumerable<inimigoWhereUniqueInput>
    update?: Enumerable<inimigoUpdateWithWhereUniqueWithoutInimigosInput>
    updateMany?: Enumerable<inimigoUpdateManyWithWhereWithoutInimigosInput>
    deleteMany?: Enumerable<inimigoScalarWhereInput>
  }

  export type inimigoUncheckedUpdateManyWithoutInimigosNestedInput = {
    create?: XOR<Enumerable<inimigoCreateWithoutInimigosInput>, Enumerable<inimigoUncheckedCreateWithoutInimigosInput>>
    connectOrCreate?: Enumerable<inimigoCreateOrConnectWithoutInimigosInput>
    upsert?: Enumerable<inimigoUpsertWithWhereUniqueWithoutInimigosInput>
    createMany?: inimigoCreateManyInimigosInputEnvelope
    set?: Enumerable<inimigoWhereUniqueInput>
    disconnect?: Enumerable<inimigoWhereUniqueInput>
    delete?: Enumerable<inimigoWhereUniqueInput>
    connect?: Enumerable<inimigoWhereUniqueInput>
    update?: Enumerable<inimigoUpdateWithWhereUniqueWithoutInimigosInput>
    updateMany?: Enumerable<inimigoUpdateManyWithWhereWithoutInimigosInput>
    deleteMany?: Enumerable<inimigoScalarWhereInput>
  }

  export type usuarioCreateNestedOneWithoutVitoriasInput = {
    create?: XOR<usuarioCreateWithoutVitoriasInput, usuarioUncheckedCreateWithoutVitoriasInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutVitoriasInput
    connect?: usuarioWhereUniqueInput
  }

  export type usuarioUpdateOneRequiredWithoutVitoriasNestedInput = {
    create?: XOR<usuarioCreateWithoutVitoriasInput, usuarioUncheckedCreateWithoutVitoriasInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutVitoriasInput
    upsert?: usuarioUpsertWithoutVitoriasInput
    connect?: usuarioWhereUniqueInput
    update?: XOR<usuarioUpdateWithoutVitoriasInput, usuarioUncheckedUpdateWithoutVitoriasInput>
  }

  export type usuarioCreateNestedOneWithoutOuroInput = {
    create?: XOR<usuarioCreateWithoutOuroInput, usuarioUncheckedCreateWithoutOuroInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutOuroInput
    connect?: usuarioWhereUniqueInput
  }

  export type usuarioUpdateOneRequiredWithoutOuroNestedInput = {
    create?: XOR<usuarioCreateWithoutOuroInput, usuarioUncheckedCreateWithoutOuroInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutOuroInput
    upsert?: usuarioUpsertWithoutOuroInput
    connect?: usuarioWhereUniqueInput
    update?: XOR<usuarioUpdateWithoutOuroInput, usuarioUncheckedUpdateWithoutOuroInput>
  }

  export type cardCreateNestedOneWithoutOuroCardInput = {
    create?: XOR<cardCreateWithoutOuroCardInput, cardUncheckedCreateWithoutOuroCardInput>
    connectOrCreate?: cardCreateOrConnectWithoutOuroCardInput
    connect?: cardWhereUniqueInput
  }

  export type cardUpdateOneRequiredWithoutOuroCardNestedInput = {
    create?: XOR<cardCreateWithoutOuroCardInput, cardUncheckedCreateWithoutOuroCardInput>
    connectOrCreate?: cardCreateOrConnectWithoutOuroCardInput
    upsert?: cardUpsertWithoutOuroCardInput
    connect?: cardWhereUniqueInput
    update?: XOR<cardUpdateWithoutOuroCardInput, cardUncheckedUpdateWithoutOuroCardInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type cardCreateWithoutDeckInput = {
    foto: string
    poder: number
    vida: number
    nome: string
    ouroCard?: ouroCardCreateNestedManyWithoutCardInput
  }

  export type cardUncheckedCreateWithoutDeckInput = {
    id?: number
    foto: string
    poder: number
    vida: number
    nome: string
    ouroCard?: ouroCardUncheckedCreateNestedManyWithoutCardInput
  }

  export type cardCreateOrConnectWithoutDeckInput = {
    where: cardWhereUniqueInput
    create: XOR<cardCreateWithoutDeckInput, cardUncheckedCreateWithoutDeckInput>
  }

  export type usuarioCreateWithoutDeckInput = {
    token: string
    senha: string
    email: string
    foto: string
    nome: string
    fase: number
    inimigo?: inimigoCreateNestedManyWithoutUsuarioInput
    ouro?: ouroCreateNestedManyWithoutUsuarioInput
    vitorias?: vitoriasCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioUncheckedCreateWithoutDeckInput = {
    id?: number
    token: string
    senha: string
    email: string
    foto: string
    nome: string
    fase: number
    inimigo?: inimigoUncheckedCreateNestedManyWithoutUsuarioInput
    ouro?: ouroUncheckedCreateNestedManyWithoutUsuarioInput
    vitorias?: vitoriasUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioCreateOrConnectWithoutDeckInput = {
    where: usuarioWhereUniqueInput
    create: XOR<usuarioCreateWithoutDeckInput, usuarioUncheckedCreateWithoutDeckInput>
  }

  export type cardUpsertWithoutDeckInput = {
    update: XOR<cardUpdateWithoutDeckInput, cardUncheckedUpdateWithoutDeckInput>
    create: XOR<cardCreateWithoutDeckInput, cardUncheckedCreateWithoutDeckInput>
  }

  export type cardUpdateWithoutDeckInput = {
    foto?: StringFieldUpdateOperationsInput | string
    poder?: IntFieldUpdateOperationsInput | number
    vida?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    ouroCard?: ouroCardUpdateManyWithoutCardNestedInput
  }

  export type cardUncheckedUpdateWithoutDeckInput = {
    id?: IntFieldUpdateOperationsInput | number
    foto?: StringFieldUpdateOperationsInput | string
    poder?: IntFieldUpdateOperationsInput | number
    vida?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    ouroCard?: ouroCardUncheckedUpdateManyWithoutCardNestedInput
  }

  export type usuarioUpsertWithoutDeckInput = {
    update: XOR<usuarioUpdateWithoutDeckInput, usuarioUncheckedUpdateWithoutDeckInput>
    create: XOR<usuarioCreateWithoutDeckInput, usuarioUncheckedCreateWithoutDeckInput>
  }

  export type usuarioUpdateWithoutDeckInput = {
    token?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    foto?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    fase?: IntFieldUpdateOperationsInput | number
    inimigo?: inimigoUpdateManyWithoutUsuarioNestedInput
    ouro?: ouroUpdateManyWithoutUsuarioNestedInput
    vitorias?: vitoriasUpdateManyWithoutUsuarioNestedInput
  }

  export type usuarioUncheckedUpdateWithoutDeckInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    foto?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    fase?: IntFieldUpdateOperationsInput | number
    inimigo?: inimigoUncheckedUpdateManyWithoutUsuarioNestedInput
    ouro?: ouroUncheckedUpdateManyWithoutUsuarioNestedInput
    vitorias?: vitoriasUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type inimigosCreateWithoutInimigoInput = {
    poder: number
    nome: string
    foto: string
    vida: number
    fase: number
  }

  export type inimigosUncheckedCreateWithoutInimigoInput = {
    id?: number
    poder: number
    nome: string
    foto: string
    vida: number
    fase: number
  }

  export type inimigosCreateOrConnectWithoutInimigoInput = {
    where: inimigosWhereUniqueInput
    create: XOR<inimigosCreateWithoutInimigoInput, inimigosUncheckedCreateWithoutInimigoInput>
  }

  export type usuarioCreateWithoutInimigoInput = {
    token: string
    senha: string
    email: string
    foto: string
    nome: string
    fase: number
    deck?: deckCreateNestedManyWithoutUsuarioInput
    ouro?: ouroCreateNestedManyWithoutUsuarioInput
    vitorias?: vitoriasCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioUncheckedCreateWithoutInimigoInput = {
    id?: number
    token: string
    senha: string
    email: string
    foto: string
    nome: string
    fase: number
    deck?: deckUncheckedCreateNestedManyWithoutUsuarioInput
    ouro?: ouroUncheckedCreateNestedManyWithoutUsuarioInput
    vitorias?: vitoriasUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioCreateOrConnectWithoutInimigoInput = {
    where: usuarioWhereUniqueInput
    create: XOR<usuarioCreateWithoutInimigoInput, usuarioUncheckedCreateWithoutInimigoInput>
  }

  export type inimigosUpsertWithoutInimigoInput = {
    update: XOR<inimigosUpdateWithoutInimigoInput, inimigosUncheckedUpdateWithoutInimigoInput>
    create: XOR<inimigosCreateWithoutInimigoInput, inimigosUncheckedCreateWithoutInimigoInput>
  }

  export type inimigosUpdateWithoutInimigoInput = {
    poder?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    foto?: StringFieldUpdateOperationsInput | string
    vida?: IntFieldUpdateOperationsInput | number
    fase?: IntFieldUpdateOperationsInput | number
  }

  export type inimigosUncheckedUpdateWithoutInimigoInput = {
    id?: IntFieldUpdateOperationsInput | number
    poder?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    foto?: StringFieldUpdateOperationsInput | string
    vida?: IntFieldUpdateOperationsInput | number
    fase?: IntFieldUpdateOperationsInput | number
  }

  export type usuarioUpsertWithoutInimigoInput = {
    update: XOR<usuarioUpdateWithoutInimigoInput, usuarioUncheckedUpdateWithoutInimigoInput>
    create: XOR<usuarioCreateWithoutInimigoInput, usuarioUncheckedCreateWithoutInimigoInput>
  }

  export type usuarioUpdateWithoutInimigoInput = {
    token?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    foto?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    fase?: IntFieldUpdateOperationsInput | number
    deck?: deckUpdateManyWithoutUsuarioNestedInput
    ouro?: ouroUpdateManyWithoutUsuarioNestedInput
    vitorias?: vitoriasUpdateManyWithoutUsuarioNestedInput
  }

  export type usuarioUncheckedUpdateWithoutInimigoInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    foto?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    fase?: IntFieldUpdateOperationsInput | number
    deck?: deckUncheckedUpdateManyWithoutUsuarioNestedInput
    ouro?: ouroUncheckedUpdateManyWithoutUsuarioNestedInput
    vitorias?: vitoriasUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type deckCreateWithoutCardInput = {
    vida: number
    maxVida: number
    nome: string
    foto: string
    poder: number
    usuario: usuarioCreateNestedOneWithoutDeckInput
  }

  export type deckUncheckedCreateWithoutCardInput = {
    id?: number
    idUser: number
    vida: number
    maxVida: number
    nome: string
    foto: string
    poder: number
  }

  export type deckCreateOrConnectWithoutCardInput = {
    where: deckWhereUniqueInput
    create: XOR<deckCreateWithoutCardInput, deckUncheckedCreateWithoutCardInput>
  }

  export type deckCreateManyCardInputEnvelope = {
    data: Enumerable<deckCreateManyCardInput>
    skipDuplicates?: boolean
  }

  export type ouroCardCreateWithoutCardInput = {
    ouro: number
  }

  export type ouroCardUncheckedCreateWithoutCardInput = {
    id?: number
    ouro: number
  }

  export type ouroCardCreateOrConnectWithoutCardInput = {
    where: ouroCardWhereUniqueInput
    create: XOR<ouroCardCreateWithoutCardInput, ouroCardUncheckedCreateWithoutCardInput>
  }

  export type ouroCardCreateManyCardInputEnvelope = {
    data: Enumerable<ouroCardCreateManyCardInput>
    skipDuplicates?: boolean
  }

  export type deckUpsertWithWhereUniqueWithoutCardInput = {
    where: deckWhereUniqueInput
    update: XOR<deckUpdateWithoutCardInput, deckUncheckedUpdateWithoutCardInput>
    create: XOR<deckCreateWithoutCardInput, deckUncheckedCreateWithoutCardInput>
  }

  export type deckUpdateWithWhereUniqueWithoutCardInput = {
    where: deckWhereUniqueInput
    data: XOR<deckUpdateWithoutCardInput, deckUncheckedUpdateWithoutCardInput>
  }

  export type deckUpdateManyWithWhereWithoutCardInput = {
    where: deckScalarWhereInput
    data: XOR<deckUpdateManyMutationInput, deckUncheckedUpdateManyWithoutDeckInput>
  }

  export type deckScalarWhereInput = {
    AND?: Enumerable<deckScalarWhereInput>
    OR?: Enumerable<deckScalarWhereInput>
    NOT?: Enumerable<deckScalarWhereInput>
    id?: IntFilter | number
    idUser?: IntFilter | number
    vida?: IntFilter | number
    maxVida?: IntFilter | number
    nome?: StringFilter | string
    foto?: StringFilter | string
    idCard?: IntFilter | number
    poder?: IntFilter | number
  }

  export type ouroCardUpsertWithWhereUniqueWithoutCardInput = {
    where: ouroCardWhereUniqueInput
    update: XOR<ouroCardUpdateWithoutCardInput, ouroCardUncheckedUpdateWithoutCardInput>
    create: XOR<ouroCardCreateWithoutCardInput, ouroCardUncheckedCreateWithoutCardInput>
  }

  export type ouroCardUpdateWithWhereUniqueWithoutCardInput = {
    where: ouroCardWhereUniqueInput
    data: XOR<ouroCardUpdateWithoutCardInput, ouroCardUncheckedUpdateWithoutCardInput>
  }

  export type ouroCardUpdateManyWithWhereWithoutCardInput = {
    where: ouroCardScalarWhereInput
    data: XOR<ouroCardUpdateManyMutationInput, ouroCardUncheckedUpdateManyWithoutOuroCardInput>
  }

  export type ouroCardScalarWhereInput = {
    AND?: Enumerable<ouroCardScalarWhereInput>
    OR?: Enumerable<ouroCardScalarWhereInput>
    NOT?: Enumerable<ouroCardScalarWhereInput>
    id?: IntFilter | number
    ouro?: IntFilter | number
    cardId?: IntFilter | number
  }

  export type deckCreateWithoutUsuarioInput = {
    vida: number
    maxVida: number
    nome: string
    foto: string
    poder: number
    card: cardCreateNestedOneWithoutDeckInput
  }

  export type deckUncheckedCreateWithoutUsuarioInput = {
    id?: number
    vida: number
    maxVida: number
    nome: string
    foto: string
    idCard: number
    poder: number
  }

  export type deckCreateOrConnectWithoutUsuarioInput = {
    where: deckWhereUniqueInput
    create: XOR<deckCreateWithoutUsuarioInput, deckUncheckedCreateWithoutUsuarioInput>
  }

  export type deckCreateManyUsuarioInputEnvelope = {
    data: Enumerable<deckCreateManyUsuarioInput>
    skipDuplicates?: boolean
  }

  export type inimigoCreateWithoutUsuarioInput = {
    nome: string
    foto: string
    fase: number
    poder: number
    vida: number
    inimigos: inimigosCreateNestedOneWithoutInimigoInput
  }

  export type inimigoUncheckedCreateWithoutUsuarioInput = {
    id?: number
    nome: string
    foto: string
    fase: number
    idInimigos: number
    poder: number
    vida: number
  }

  export type inimigoCreateOrConnectWithoutUsuarioInput = {
    where: inimigoWhereUniqueInput
    create: XOR<inimigoCreateWithoutUsuarioInput, inimigoUncheckedCreateWithoutUsuarioInput>
  }

  export type inimigoCreateManyUsuarioInputEnvelope = {
    data: Enumerable<inimigoCreateManyUsuarioInput>
    skipDuplicates?: boolean
  }

  export type ouroCreateWithoutUsuarioInput = {
    ouro: number
  }

  export type ouroUncheckedCreateWithoutUsuarioInput = {
    id?: number
    ouro: number
  }

  export type ouroCreateOrConnectWithoutUsuarioInput = {
    where: ouroWhereUniqueInput
    create: XOR<ouroCreateWithoutUsuarioInput, ouroUncheckedCreateWithoutUsuarioInput>
  }

  export type ouroCreateManyUsuarioInputEnvelope = {
    data: Enumerable<ouroCreateManyUsuarioInput>
    skipDuplicates?: boolean
  }

  export type vitoriasCreateWithoutUsuarioInput = {
    vitorias: number
  }

  export type vitoriasUncheckedCreateWithoutUsuarioInput = {
    id?: number
    vitorias: number
  }

  export type vitoriasCreateOrConnectWithoutUsuarioInput = {
    where: vitoriasWhereUniqueInput
    create: XOR<vitoriasCreateWithoutUsuarioInput, vitoriasUncheckedCreateWithoutUsuarioInput>
  }

  export type vitoriasCreateManyUsuarioInputEnvelope = {
    data: Enumerable<vitoriasCreateManyUsuarioInput>
    skipDuplicates?: boolean
  }

  export type deckUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: deckWhereUniqueInput
    update: XOR<deckUpdateWithoutUsuarioInput, deckUncheckedUpdateWithoutUsuarioInput>
    create: XOR<deckCreateWithoutUsuarioInput, deckUncheckedCreateWithoutUsuarioInput>
  }

  export type deckUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: deckWhereUniqueInput
    data: XOR<deckUpdateWithoutUsuarioInput, deckUncheckedUpdateWithoutUsuarioInput>
  }

  export type deckUpdateManyWithWhereWithoutUsuarioInput = {
    where: deckScalarWhereInput
    data: XOR<deckUpdateManyMutationInput, deckUncheckedUpdateManyWithoutDeckInput>
  }

  export type inimigoUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: inimigoWhereUniqueInput
    update: XOR<inimigoUpdateWithoutUsuarioInput, inimigoUncheckedUpdateWithoutUsuarioInput>
    create: XOR<inimigoCreateWithoutUsuarioInput, inimigoUncheckedCreateWithoutUsuarioInput>
  }

  export type inimigoUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: inimigoWhereUniqueInput
    data: XOR<inimigoUpdateWithoutUsuarioInput, inimigoUncheckedUpdateWithoutUsuarioInput>
  }

  export type inimigoUpdateManyWithWhereWithoutUsuarioInput = {
    where: inimigoScalarWhereInput
    data: XOR<inimigoUpdateManyMutationInput, inimigoUncheckedUpdateManyWithoutInimigoInput>
  }

  export type inimigoScalarWhereInput = {
    AND?: Enumerable<inimigoScalarWhereInput>
    OR?: Enumerable<inimigoScalarWhereInput>
    NOT?: Enumerable<inimigoScalarWhereInput>
    id?: IntFilter | number
    nome?: StringFilter | string
    foto?: StringFilter | string
    fase?: IntFilter | number
    idUsuario?: IntFilter | number
    idInimigos?: IntFilter | number
    poder?: IntFilter | number
    vida?: IntFilter | number
  }

  export type ouroUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: ouroWhereUniqueInput
    update: XOR<ouroUpdateWithoutUsuarioInput, ouroUncheckedUpdateWithoutUsuarioInput>
    create: XOR<ouroCreateWithoutUsuarioInput, ouroUncheckedCreateWithoutUsuarioInput>
  }

  export type ouroUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: ouroWhereUniqueInput
    data: XOR<ouroUpdateWithoutUsuarioInput, ouroUncheckedUpdateWithoutUsuarioInput>
  }

  export type ouroUpdateManyWithWhereWithoutUsuarioInput = {
    where: ouroScalarWhereInput
    data: XOR<ouroUpdateManyMutationInput, ouroUncheckedUpdateManyWithoutOuroInput>
  }

  export type ouroScalarWhereInput = {
    AND?: Enumerable<ouroScalarWhereInput>
    OR?: Enumerable<ouroScalarWhereInput>
    NOT?: Enumerable<ouroScalarWhereInput>
    id?: IntFilter | number
    ouro?: IntFilter | number
    usuarioId?: IntFilter | number
  }

  export type vitoriasUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: vitoriasWhereUniqueInput
    update: XOR<vitoriasUpdateWithoutUsuarioInput, vitoriasUncheckedUpdateWithoutUsuarioInput>
    create: XOR<vitoriasCreateWithoutUsuarioInput, vitoriasUncheckedCreateWithoutUsuarioInput>
  }

  export type vitoriasUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: vitoriasWhereUniqueInput
    data: XOR<vitoriasUpdateWithoutUsuarioInput, vitoriasUncheckedUpdateWithoutUsuarioInput>
  }

  export type vitoriasUpdateManyWithWhereWithoutUsuarioInput = {
    where: vitoriasScalarWhereInput
    data: XOR<vitoriasUpdateManyMutationInput, vitoriasUncheckedUpdateManyWithoutVitoriasInput>
  }

  export type vitoriasScalarWhereInput = {
    AND?: Enumerable<vitoriasScalarWhereInput>
    OR?: Enumerable<vitoriasScalarWhereInput>
    NOT?: Enumerable<vitoriasScalarWhereInput>
    id?: IntFilter | number
    vitorias?: IntFilter | number
    usuarioId?: IntFilter | number
  }

  export type inimigoCreateWithoutInimigosInput = {
    nome: string
    foto: string
    fase: number
    poder: number
    vida: number
    usuario: usuarioCreateNestedOneWithoutInimigoInput
  }

  export type inimigoUncheckedCreateWithoutInimigosInput = {
    id?: number
    nome: string
    foto: string
    fase: number
    idUsuario: number
    poder: number
    vida: number
  }

  export type inimigoCreateOrConnectWithoutInimigosInput = {
    where: inimigoWhereUniqueInput
    create: XOR<inimigoCreateWithoutInimigosInput, inimigoUncheckedCreateWithoutInimigosInput>
  }

  export type inimigoCreateManyInimigosInputEnvelope = {
    data: Enumerable<inimigoCreateManyInimigosInput>
    skipDuplicates?: boolean
  }

  export type inimigoUpsertWithWhereUniqueWithoutInimigosInput = {
    where: inimigoWhereUniqueInput
    update: XOR<inimigoUpdateWithoutInimigosInput, inimigoUncheckedUpdateWithoutInimigosInput>
    create: XOR<inimigoCreateWithoutInimigosInput, inimigoUncheckedCreateWithoutInimigosInput>
  }

  export type inimigoUpdateWithWhereUniqueWithoutInimigosInput = {
    where: inimigoWhereUniqueInput
    data: XOR<inimigoUpdateWithoutInimigosInput, inimigoUncheckedUpdateWithoutInimigosInput>
  }

  export type inimigoUpdateManyWithWhereWithoutInimigosInput = {
    where: inimigoScalarWhereInput
    data: XOR<inimigoUpdateManyMutationInput, inimigoUncheckedUpdateManyWithoutInimigoInput>
  }

  export type usuarioCreateWithoutVitoriasInput = {
    token: string
    senha: string
    email: string
    foto: string
    nome: string
    fase: number
    deck?: deckCreateNestedManyWithoutUsuarioInput
    inimigo?: inimigoCreateNestedManyWithoutUsuarioInput
    ouro?: ouroCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioUncheckedCreateWithoutVitoriasInput = {
    id?: number
    token: string
    senha: string
    email: string
    foto: string
    nome: string
    fase: number
    deck?: deckUncheckedCreateNestedManyWithoutUsuarioInput
    inimigo?: inimigoUncheckedCreateNestedManyWithoutUsuarioInput
    ouro?: ouroUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioCreateOrConnectWithoutVitoriasInput = {
    where: usuarioWhereUniqueInput
    create: XOR<usuarioCreateWithoutVitoriasInput, usuarioUncheckedCreateWithoutVitoriasInput>
  }

  export type usuarioUpsertWithoutVitoriasInput = {
    update: XOR<usuarioUpdateWithoutVitoriasInput, usuarioUncheckedUpdateWithoutVitoriasInput>
    create: XOR<usuarioCreateWithoutVitoriasInput, usuarioUncheckedCreateWithoutVitoriasInput>
  }

  export type usuarioUpdateWithoutVitoriasInput = {
    token?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    foto?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    fase?: IntFieldUpdateOperationsInput | number
    deck?: deckUpdateManyWithoutUsuarioNestedInput
    inimigo?: inimigoUpdateManyWithoutUsuarioNestedInput
    ouro?: ouroUpdateManyWithoutUsuarioNestedInput
  }

  export type usuarioUncheckedUpdateWithoutVitoriasInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    foto?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    fase?: IntFieldUpdateOperationsInput | number
    deck?: deckUncheckedUpdateManyWithoutUsuarioNestedInput
    inimigo?: inimigoUncheckedUpdateManyWithoutUsuarioNestedInput
    ouro?: ouroUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type usuarioCreateWithoutOuroInput = {
    token: string
    senha: string
    email: string
    foto: string
    nome: string
    fase: number
    deck?: deckCreateNestedManyWithoutUsuarioInput
    inimigo?: inimigoCreateNestedManyWithoutUsuarioInput
    vitorias?: vitoriasCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioUncheckedCreateWithoutOuroInput = {
    id?: number
    token: string
    senha: string
    email: string
    foto: string
    nome: string
    fase: number
    deck?: deckUncheckedCreateNestedManyWithoutUsuarioInput
    inimigo?: inimigoUncheckedCreateNestedManyWithoutUsuarioInput
    vitorias?: vitoriasUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioCreateOrConnectWithoutOuroInput = {
    where: usuarioWhereUniqueInput
    create: XOR<usuarioCreateWithoutOuroInput, usuarioUncheckedCreateWithoutOuroInput>
  }

  export type usuarioUpsertWithoutOuroInput = {
    update: XOR<usuarioUpdateWithoutOuroInput, usuarioUncheckedUpdateWithoutOuroInput>
    create: XOR<usuarioCreateWithoutOuroInput, usuarioUncheckedCreateWithoutOuroInput>
  }

  export type usuarioUpdateWithoutOuroInput = {
    token?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    foto?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    fase?: IntFieldUpdateOperationsInput | number
    deck?: deckUpdateManyWithoutUsuarioNestedInput
    inimigo?: inimigoUpdateManyWithoutUsuarioNestedInput
    vitorias?: vitoriasUpdateManyWithoutUsuarioNestedInput
  }

  export type usuarioUncheckedUpdateWithoutOuroInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    foto?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    fase?: IntFieldUpdateOperationsInput | number
    deck?: deckUncheckedUpdateManyWithoutUsuarioNestedInput
    inimigo?: inimigoUncheckedUpdateManyWithoutUsuarioNestedInput
    vitorias?: vitoriasUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type cardCreateWithoutOuroCardInput = {
    foto: string
    poder: number
    vida: number
    nome: string
    deck?: deckCreateNestedManyWithoutCardInput
  }

  export type cardUncheckedCreateWithoutOuroCardInput = {
    id?: number
    foto: string
    poder: number
    vida: number
    nome: string
    deck?: deckUncheckedCreateNestedManyWithoutCardInput
  }

  export type cardCreateOrConnectWithoutOuroCardInput = {
    where: cardWhereUniqueInput
    create: XOR<cardCreateWithoutOuroCardInput, cardUncheckedCreateWithoutOuroCardInput>
  }

  export type cardUpsertWithoutOuroCardInput = {
    update: XOR<cardUpdateWithoutOuroCardInput, cardUncheckedUpdateWithoutOuroCardInput>
    create: XOR<cardCreateWithoutOuroCardInput, cardUncheckedCreateWithoutOuroCardInput>
  }

  export type cardUpdateWithoutOuroCardInput = {
    foto?: StringFieldUpdateOperationsInput | string
    poder?: IntFieldUpdateOperationsInput | number
    vida?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    deck?: deckUpdateManyWithoutCardNestedInput
  }

  export type cardUncheckedUpdateWithoutOuroCardInput = {
    id?: IntFieldUpdateOperationsInput | number
    foto?: StringFieldUpdateOperationsInput | string
    poder?: IntFieldUpdateOperationsInput | number
    vida?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    deck?: deckUncheckedUpdateManyWithoutCardNestedInput
  }

  export type deckCreateManyCardInput = {
    id?: number
    idUser: number
    vida: number
    maxVida: number
    nome: string
    foto: string
    poder: number
  }

  export type ouroCardCreateManyCardInput = {
    id?: number
    ouro: number
  }

  export type deckUpdateWithoutCardInput = {
    vida?: IntFieldUpdateOperationsInput | number
    maxVida?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    foto?: StringFieldUpdateOperationsInput | string
    poder?: IntFieldUpdateOperationsInput | number
    usuario?: usuarioUpdateOneRequiredWithoutDeckNestedInput
  }

  export type deckUncheckedUpdateWithoutCardInput = {
    id?: IntFieldUpdateOperationsInput | number
    idUser?: IntFieldUpdateOperationsInput | number
    vida?: IntFieldUpdateOperationsInput | number
    maxVida?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    foto?: StringFieldUpdateOperationsInput | string
    poder?: IntFieldUpdateOperationsInput | number
  }

  export type deckUncheckedUpdateManyWithoutDeckInput = {
    id?: IntFieldUpdateOperationsInput | number
    idUser?: IntFieldUpdateOperationsInput | number
    vida?: IntFieldUpdateOperationsInput | number
    maxVida?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    foto?: StringFieldUpdateOperationsInput | string
    poder?: IntFieldUpdateOperationsInput | number
  }

  export type ouroCardUpdateWithoutCardInput = {
    ouro?: IntFieldUpdateOperationsInput | number
  }

  export type ouroCardUncheckedUpdateWithoutCardInput = {
    id?: IntFieldUpdateOperationsInput | number
    ouro?: IntFieldUpdateOperationsInput | number
  }

  export type ouroCardUncheckedUpdateManyWithoutOuroCardInput = {
    id?: IntFieldUpdateOperationsInput | number
    ouro?: IntFieldUpdateOperationsInput | number
  }

  export type deckCreateManyUsuarioInput = {
    id?: number
    vida: number
    maxVida: number
    nome: string
    foto: string
    idCard: number
    poder: number
  }

  export type inimigoCreateManyUsuarioInput = {
    id?: number
    nome: string
    foto: string
    fase: number
    idInimigos: number
    poder: number
    vida: number
  }

  export type ouroCreateManyUsuarioInput = {
    id?: number
    ouro: number
  }

  export type vitoriasCreateManyUsuarioInput = {
    id?: number
    vitorias: number
  }

  export type deckUpdateWithoutUsuarioInput = {
    vida?: IntFieldUpdateOperationsInput | number
    maxVida?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    foto?: StringFieldUpdateOperationsInput | string
    poder?: IntFieldUpdateOperationsInput | number
    card?: cardUpdateOneRequiredWithoutDeckNestedInput
  }

  export type deckUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    vida?: IntFieldUpdateOperationsInput | number
    maxVida?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    foto?: StringFieldUpdateOperationsInput | string
    idCard?: IntFieldUpdateOperationsInput | number
    poder?: IntFieldUpdateOperationsInput | number
  }

  export type inimigoUpdateWithoutUsuarioInput = {
    nome?: StringFieldUpdateOperationsInput | string
    foto?: StringFieldUpdateOperationsInput | string
    fase?: IntFieldUpdateOperationsInput | number
    poder?: IntFieldUpdateOperationsInput | number
    vida?: IntFieldUpdateOperationsInput | number
    inimigos?: inimigosUpdateOneRequiredWithoutInimigoNestedInput
  }

  export type inimigoUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    foto?: StringFieldUpdateOperationsInput | string
    fase?: IntFieldUpdateOperationsInput | number
    idInimigos?: IntFieldUpdateOperationsInput | number
    poder?: IntFieldUpdateOperationsInput | number
    vida?: IntFieldUpdateOperationsInput | number
  }

  export type inimigoUncheckedUpdateManyWithoutInimigoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    foto?: StringFieldUpdateOperationsInput | string
    fase?: IntFieldUpdateOperationsInput | number
    idInimigos?: IntFieldUpdateOperationsInput | number
    poder?: IntFieldUpdateOperationsInput | number
    vida?: IntFieldUpdateOperationsInput | number
  }

  export type ouroUpdateWithoutUsuarioInput = {
    ouro?: IntFieldUpdateOperationsInput | number
  }

  export type ouroUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    ouro?: IntFieldUpdateOperationsInput | number
  }

  export type ouroUncheckedUpdateManyWithoutOuroInput = {
    id?: IntFieldUpdateOperationsInput | number
    ouro?: IntFieldUpdateOperationsInput | number
  }

  export type vitoriasUpdateWithoutUsuarioInput = {
    vitorias?: IntFieldUpdateOperationsInput | number
  }

  export type vitoriasUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    vitorias?: IntFieldUpdateOperationsInput | number
  }

  export type vitoriasUncheckedUpdateManyWithoutVitoriasInput = {
    id?: IntFieldUpdateOperationsInput | number
    vitorias?: IntFieldUpdateOperationsInput | number
  }

  export type inimigoCreateManyInimigosInput = {
    id?: number
    nome: string
    foto: string
    fase: number
    idUsuario: number
    poder: number
    vida: number
  }

  export type inimigoUpdateWithoutInimigosInput = {
    nome?: StringFieldUpdateOperationsInput | string
    foto?: StringFieldUpdateOperationsInput | string
    fase?: IntFieldUpdateOperationsInput | number
    poder?: IntFieldUpdateOperationsInput | number
    vida?: IntFieldUpdateOperationsInput | number
    usuario?: usuarioUpdateOneRequiredWithoutInimigoNestedInput
  }

  export type inimigoUncheckedUpdateWithoutInimigosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    foto?: StringFieldUpdateOperationsInput | string
    fase?: IntFieldUpdateOperationsInput | number
    idUsuario?: IntFieldUpdateOperationsInput | number
    poder?: IntFieldUpdateOperationsInput | number
    vida?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}